/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
    "/static/web-videos/{filename}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get public Web Video file
         * @description **PeerTube >= 6.0**
         */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    /** @description Filename */
                    filename: components["parameters"]["staticFilename"];
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description successful operation */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                /** @description not found */
                404: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/static/web-videos/private/{filename}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get private Web Video file
         * @description **PeerTube >= 6.0**
         */
        get: {
            parameters: {
                query?: {
                    /** @description Video file token [generated](#operation/requestVideoToken) by PeerTube so you don't need to provide an OAuth token in the request header. */
                    videoFileToken?: components["parameters"]["videoFileToken"];
                };
                header?: never;
                path: {
                    /** @description Filename */
                    filename: components["parameters"]["staticFilename"];
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description successful operation */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                /** @description invalid auth */
                403: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                /** @description not found */
                404: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/static/streaming-playlists/hls/{filename}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get public HLS video file */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    /** @description Filename */
                    filename: components["parameters"]["staticFilename"];
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description successful operation */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                /** @description invalid auth */
                403: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                /** @description not found */
                404: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/static/streaming-playlists/hls/private/{filename}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get private HLS video file */
        get: {
            parameters: {
                query?: {
                    /** @description Video file token [generated](#operation/requestVideoToken) by PeerTube so you don't need to provide an OAuth token in the request header. */
                    videoFileToken?: components["parameters"]["videoFileToken"];
                    /** @description Ask the server to reinject videoFileToken in URLs in m3u8 playlist */
                    reinjectVideoFileToken?: components["parameters"]["reinjectVideoFileToken"];
                };
                header?: never;
                path: {
                    /** @description Filename */
                    filename: components["parameters"]["staticFilename"];
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description successful operation */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                /** @description invalid auth */
                403: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                /** @description not found */
                404: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/download/videos/generate/:videoId": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Download video file
         * @description Generate a mp4 container that contains at most 1 video stream and at most 1 audio stream. Mainly used to merge the HLS audio only video file and the HLS video only resolution file.
         */
        get: {
            parameters: {
                query: {
                    /** @description streams of video files to mux in the output */
                    videoFileIds: number[];
                    /** @description Video file token [generated](#operation/requestVideoToken) by PeerTube so you don't need to provide an OAuth token in the request header. */
                    videoFileToken?: components["parameters"]["videoFileToken"];
                };
                header?: never;
                path: {
                    /** @description The video id */
                    videoId: components["schemas"]["Video"]["id"];
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description successful operation */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/feeds/video-comments.{format}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Comments on videos feeds */
        get: operations["getSyndicatedComments"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/feeds/videos.{format}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Common videos feeds */
        get: operations["getSyndicatedVideos"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/feeds/subscriptions.{format}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Videos of subscriptions feeds */
        get: operations["getSyndicatedSubscriptionVideos"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/feeds/podcast/videos.xml": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Videos podcast feed */
        get: operations["getVideosPodcastFeed"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/accounts/{name}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get an account */
        get: operations["getAccount"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/accounts/{name}/videos": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List videos of an account */
        get: operations["getAccountVideos"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/accounts/{name}/followers": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List followers of an account */
        get: operations["getAccountFollowers"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/accounts": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List accounts */
        get: operations["getAccounts"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/config": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get instance public configuration */
        get: operations["getConfig"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/config/about": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get instance "About" information */
        get: operations["getAbout"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/config/custom": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get instance runtime configuration */
        get: operations["getCustomConfig"];
        /** Set instance runtime configuration */
        put: operations["putCustomConfig"];
        post?: never;
        /** Delete instance runtime configuration */
        delete: operations["delCustomConfig"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/config/instance-banner/pick": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Update instance banner */
        post: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "multipart/form-data": {
                        /**
                         * Format: binary
                         * @description The file to upload.
                         */
                        bannerfile?: string;
                    };
                };
            };
            responses: {
                /** @description successful operation */
                204: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                /** @description image file too large */
                413: {
                    headers: {
                        /** @description Maximum file size for the banner */
                        "X-File-Maximum-Size"?: string;
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/config/instance-banner": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        /** Delete instance banner */
        delete: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description successful operation */
                204: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/config/instance-avatar/pick": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Update instance avatar */
        post: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "multipart/form-data": {
                        /**
                         * Format: binary
                         * @description The file to upload.
                         */
                        avatarfile?: string;
                    };
                };
            };
            responses: {
                /** @description successful operation */
                204: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                /** @description image file too large */
                413: {
                    headers: {
                        /** @description Maximum file size for the avatar */
                        "X-File-Maximum-Size"?: string;
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/config/instance-avatar": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        /** Delete instance avatar */
        delete: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description successful operation */
                204: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/custom-pages/homepage/instance": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get instance custom homepage */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description successful operation */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["CustomHomepage"];
                    };
                };
                /** @description No homepage set */
                404: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        /** Set instance custom homepage */
        put: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": {
                        /** @description content of the homepage, that will be injected in the client */
                        content?: string;
                    };
                };
            };
            responses: {
                /** @description successful operation */
                204: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/jobs/pause": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Pause job queue */
        post: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description successful operation */
                204: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/jobs/resume": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Resume job queue */
        post: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description successful operation */
                204: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/jobs/{state}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List instance jobs */
        get: operations["getJobs"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/server/followers": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List instances following the server */
        get: {
            parameters: {
                query?: {
                    state?: components["parameters"]["followState"];
                    actorType?: components["parameters"]["actorType"];
                    /** @description Offset used to paginate results */
                    start?: components["parameters"]["start"];
                    /** @description Number of items to return */
                    count?: components["parameters"]["count"];
                    /** @description Sort column */
                    sort?: components["parameters"]["sort"];
                };
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description successful operation */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": {
                            /** @example 1 */
                            total?: number;
                            data?: components["schemas"]["Follow"][];
                        };
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/server/followers/{handle}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        /** Remove or reject a follower to your server */
        delete: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    /** @description The remote actor handle to remove from your followers */
                    handle: string;
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description successful operation */
                204: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                /** @description follower not found */
                404: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/server/followers/{handle}/reject": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Reject a pending follower to your server */
        post: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    /** @description The remote actor handle to remove from your followers */
                    handle: string;
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description successful operation */
                204: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                /** @description follower not found */
                404: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/server/followers/{handle}/accept": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Accept a pending follower to your server */
        post: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    /** @description The remote actor handle to remove from your followers */
                    handle: string;
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description successful operation */
                204: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                /** @description follower not found */
                404: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/server/following": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List instances followed by the server */
        get: {
            parameters: {
                query?: {
                    state?: components["parameters"]["followState"];
                    actorType?: components["parameters"]["actorType"];
                    /** @description Offset used to paginate results */
                    start?: components["parameters"]["start"];
                    /** @description Number of items to return */
                    count?: components["parameters"]["count"];
                    /** @description Sort column */
                    sort?: components["parameters"]["sort"];
                };
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description successful operation */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": {
                            /** @example 1 */
                            total?: number;
                            data?: components["schemas"]["Follow"][];
                        };
                    };
                };
            };
        };
        put?: never;
        /** Follow a list of actors (PeerTube instance, channel or account) */
        post: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": {
                        hosts?: string[];
                        handles?: string[];
                    };
                };
            };
            responses: {
                /** @description successful operation */
                204: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                /** @description cannot follow a non-HTTPS server */
                500: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/server/following/{hostOrHandle}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        /** Unfollow an actor (PeerTube instance, channel or account) */
        delete: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    /** @description The hostOrHandle to unfollow */
                    hostOrHandle: string;
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description successful operation */
                204: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                /** @description host or handle not found */
                404: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/users": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List users */
        get: operations["getUsers"];
        put?: never;
        /** Create a user */
        post: operations["addUser"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/users/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Entity id */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        /** Get a user */
        get: operations["getUser"];
        /** Update a user */
        put: operations["putUser"];
        post?: never;
        /** Delete a user */
        delete: operations["delUser"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/oauth-clients/local": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Login prerequisite
         * @description You need to retrieve a client id and secret before [logging in](#operation/getOAuthToken).
         */
        get: operations["getOAuthClient"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/users/token": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Login
         * @description With your [client id and secret](#operation/getOAuthClient), you can retrieve an access and refresh tokens.
         */
        post: operations["getOAuthToken"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/users/revoke-token": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Logout
         * @description Revokes your access token and its associated refresh token, destroying your current session.
         */
        post: operations["revokeOAuthToken"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/users/ask-send-verify-email": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Resend user verification link */
        post: operations["resendEmailToVerifyUser"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/users/registrations/ask-send-verify-email": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Resend verification link to registration request email */
        post: operations["resendEmailToVerifyRegistration"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/users/{id}/verify-email": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Verify a user
         * @description Following a user registration, the new user will receive an email asking to click a link
         *     containing a secret.
         *     This endpoint can also be used to verify a new email set in the user account.
         *
         */
        post: operations["verifyUser"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/users/registrations/{registrationId}/verify-email": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Verify a registration email
         * @description Following a user registration request, the user will receive an email asking to click a link
         *     containing a secret.
         *
         */
        post: operations["verifyRegistrationEmail"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/users/ask-reset-password": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Ask to reset password
         * @description An email containing a reset password link
         */
        post: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": {
                        /** @description User email */
                        email: string;
                    };
                };
            };
            responses: {
                /** @description successful operation */
                204: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/users/{id}/reset-password": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Reset password */
        post: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    /** @description Entity id */
                    id: components["parameters"]["id"];
                };
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": {
                        /** Format: url */
                        verificationString: string;
                        password: string;
                    };
                };
            };
            responses: {
                /** @description successful operation */
                204: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                /** @description invalid verification string */
                403: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                /** @description user not found */
                404: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/users/{id}/two-factor/request": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Request two factor auth
         * @description Request two factor authentication for a user
         */
        post: operations["requestTwoFactor"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/users/{id}/two-factor/confirm-request": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Confirm two factor auth
         * @description Confirm a two factor authentication request
         */
        post: operations["confirmTwoFactorRequest"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/users/{id}/two-factor/disable": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Disable two factor auth
         * @description Disable two factor authentication of a user
         */
        post: operations["disableTwoFactor"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/users/{userId}/imports/import-resumable": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        /**
         * Send chunk for the resumable user import
         * @description **PeerTube >= 6.1** Uses [a resumable protocol](https://github.com/kukhariev/node-uploadx/blob/master/proto.md) to continue, pause or resume the import of the archive
         */
        put: operations["userImportResumable"];
        /**
         * Initialize the resumable user import
         * @description **PeerTube >= 6.1** Uses [a resumable protocol](https://github.com/kukhariev/node-uploadx/blob/master/proto.md) to initialize the import of the archive
         */
        post: operations["userImportResumableInit"];
        /**
         * Cancel the resumable user import
         * @description **PeerTube >= 6.1** Uses [a resumable protocol](https://github.com/kukhariev/node-uploadx/blob/master/proto.md) to cancel the resumable user import
         */
        delete: operations["userImportResumableCancel"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/users/{userId}/imports/latest": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get latest user import
         * @description **PeerTube >= 6.1**
         */
        get: operations["getLatestUserImport"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/users/{userId}/exports/request": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Request user export
         * @description Request an archive of user data. An email is sent when the archive is ready.
         */
        post: operations["requestUserExport"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/users/{userId}/exports": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List user exports
         * @description **PeerTube >= 6.1**
         */
        get: operations["listUserExports"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/users/{userId}/exports/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        /**
         * Delete a user export
         * @description **PeerTube >= 6.1**
         */
        delete: operations["deleteUserExport"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/users/me": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get my user information */
        get: operations["getUserInfo"];
        /** Update my user information */
        put: operations["putUserInfo"];
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/users/me/videos/comments": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List comments on user's videos
         * @description **PeerTube >= 6.2**
         */
        get: {
            parameters: {
                query?: {
                    /** @description Plain text search, applied to various parts of the model depending on endpoint */
                    search?: components["parameters"]["search"];
                    /** @description Filter comments by searching on the account */
                    searchAccount?: components["parameters"]["searchAccountForComments"];
                    /** @description Filter comments by searching on the video */
                    searchVideo?: components["parameters"]["searchVideoForComments"];
                    /** @description Limit results on this specific video */
                    videoId?: components["parameters"]["videoId"];
                    /** @description Limit results on this specific video channel */
                    videoChannelId?: components["parameters"]["videoChannelId"];
                    /** @description **PeerTube >= 6.2** filter on comments that contain one of these automatic tags */
                    autoTagOneOf?: components["parameters"]["autoTagOneOfComment"];
                    /** @description only display comments that are held for review */
                    isHeldForReview?: components["parameters"]["isHeldForReview"];
                };
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description successful operation */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": {
                            /** @example 1 */
                            total?: number;
                            data?: components["schemas"]["VideoCommentForOwnerOrAdmin"][];
                        };
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/users/me/videos/imports": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get video imports of my user */
        get: {
            parameters: {
                query?: {
                    /** @description Offset used to paginate results */
                    start?: components["parameters"]["start"];
                    /** @description Number of items to return */
                    count?: components["parameters"]["count"];
                    /** @description Sort column */
                    sort?: components["parameters"]["sort"];
                    /** @description Filter on import target URL */
                    targetUrl?: string;
                    /** @description Filter on imports created by a specific channel synchronization */
                    videoChannelSyncId?: number;
                    /** @description Search in video names */
                    search?: string;
                };
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description successful operation */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["VideoImportsList"];
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/users/me/video-quota-used": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get my user used quota */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description successful operation */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": {
                            /**
                             * @description The user video quota used so far in bytes
                             * @example 16810141515
                             */
                            videoQuotaUsed?: number;
                            /**
                             * @description The user video quota used today in bytes
                             * @example 1681014151
                             */
                            videoQuotaUsedDaily?: number;
                        };
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/users/me/videos/{videoId}/rating": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get rate of my user for a video */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    /** @description The video id */
                    videoId: components["schemas"]["Video"]["id"];
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description successful operation */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["GetMeVideoRating"];
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/users/me/videos": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List videos of my user */
        get: {
            parameters: {
                query?: {
                    /** @description **PeerTube >= 7.2** Filter on videos that are published by a channel with one of these names */
                    channelNameOneOf?: components["parameters"]["channelNameOneOf"];
                    /** @description Offset used to paginate results */
                    start?: components["parameters"]["start"];
                    /** @description Number of items to return */
                    count?: components["parameters"]["count"];
                    /** @description if you don't need the `total` in the response */
                    skipCount?: components["parameters"]["skipCount"];
                    sort?: components["parameters"]["videosSort"];
                    /** @description whether to include nsfw videos, if any */
                    nsfw?: components["parameters"]["nsfw"];
                    nsfwFlagsIncluded?: components["parameters"]["nsfwFlagsIncluded"];
                    nsfwFlagsExcluded?: components["parameters"]["nsfwFlagsExcluded"];
                    /** @description whether or not the video is a live */
                    isLive?: components["parameters"]["isLive"];
                    /** @description category id of the video (see [/videos/categories](#operation/getCategories)) */
                    categoryOneOf?: components["parameters"]["categoryOneOf"];
                    /** @description licence id of the video (see [/videos/licences](#operation/getLicences)) */
                    licenceOneOf?: components["parameters"]["licenceOneOf"];
                    /** @description language id of the video (see [/videos/languages](#operation/getLanguages)). Use `_unknown` to filter on videos that don't have a video language */
                    languageOneOf?: components["parameters"]["languageOneOf"];
                    /** @description tag(s) of the video */
                    tagsOneOf?: components["parameters"]["tagsOneOf"];
                    /** @description tag(s) of the video, where all should be present in the video */
                    tagsAllOf?: components["parameters"]["tagsAllOf"];
                    /** @description **PeerTube >= 4.0** Display only local or remote objects */
                    isLocal?: components["parameters"]["isLocal"];
                    /** @description **Only administrators and moderators can use this parameter**
                     *
                     *     Include additional videos in results (can be combined using bitwise or operator)
                     *     - `0` NONE
                     *     - `1` NOT_PUBLISHED_STATE
                     *     - `2` BLACKLISTED
                     *     - `4` BLOCKED_OWNER
                     *     - `8` FILES
                     *     - `16` CAPTIONS
                     *     - `32` VIDEO SOURCE
                     *      */
                    include?: components["parameters"]["include"];
                    /** @description **PeerTube >= 4.0** Display only videos that have HLS files */
                    hasHLSFiles?: components["parameters"]["hasHLSFiles"];
                    /** @description **PeerTube >= 6.0** Display only videos that have Web Video files */
                    hasWebVideoFiles?: components["parameters"]["hasWebVideoFiles"];
                    /** @description Find elements owned by this host */
                    host?: components["parameters"]["host"];
                    /** @description **PeerTube >= 6.2** **Admins and moderators only** filter on videos that contain one of these automatic tags */
                    autoTagOneOf?: components["parameters"]["autoTagOneOfVideo"];
                    /** @description **PeerTube >= 4.0** Display only videos in this specific privacy/privacies */
                    privacyOneOf?: components["parameters"]["privacyOneOf"];
                    /** @description Whether or not to exclude videos that are in the user's video history */
                    excludeAlreadyWatched?: components["parameters"]["excludeAlreadyWatched"];
                    /** @description Plain text search, applied to various parts of the model depending on endpoint */
                    search?: components["parameters"]["search"];
                };
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description successful operation */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["VideoListResponse"];
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/users/me/subscriptions": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List my user subscriptions */
        get: {
            parameters: {
                query?: {
                    /** @description Offset used to paginate results */
                    start?: components["parameters"]["start"];
                    /** @description Number of items to return */
                    count?: components["parameters"]["count"];
                    sort?: components["parameters"]["mySubscriptionSort"];
                };
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description successful operation */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["VideoChannelList"];
                    };
                };
            };
        };
        put?: never;
        /** Add subscription to my user */
        post: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": {
                        /**
                         * Format: uri
                         * @description uri of the video channels to subscribe to
                         */
                        uri: string;
                    };
                };
            };
            responses: {
                /** @description successful operation */
                204: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/users/me/subscriptions/exist": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get if subscriptions exist for my user */
        get: {
            parameters: {
                query: {
                    /** @description list of uris to check if each is part of the user subscriptions */
                    uris: components["parameters"]["subscriptionsUris"];
                };
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description successful operation */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": Record<string, never>;
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/users/me/subscriptions/videos": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List videos of subscriptions of my user */
        get: {
            parameters: {
                query?: {
                    /** @description Offset used to paginate results */
                    start?: components["parameters"]["start"];
                    /** @description Number of items to return */
                    count?: components["parameters"]["count"];
                    /** @description if you don't need the `total` in the response */
                    skipCount?: components["parameters"]["skipCount"];
                    sort?: components["parameters"]["videosSort"];
                    /** @description whether to include nsfw videos, if any */
                    nsfw?: components["parameters"]["nsfw"];
                    nsfwFlagsIncluded?: components["parameters"]["nsfwFlagsIncluded"];
                    nsfwFlagsExcluded?: components["parameters"]["nsfwFlagsExcluded"];
                    /** @description whether or not the video is a live */
                    isLive?: components["parameters"]["isLive"];
                    /** @description category id of the video (see [/videos/categories](#operation/getCategories)) */
                    categoryOneOf?: components["parameters"]["categoryOneOf"];
                    /** @description licence id of the video (see [/videos/licences](#operation/getLicences)) */
                    licenceOneOf?: components["parameters"]["licenceOneOf"];
                    /** @description language id of the video (see [/videos/languages](#operation/getLanguages)). Use `_unknown` to filter on videos that don't have a video language */
                    languageOneOf?: components["parameters"]["languageOneOf"];
                    /** @description tag(s) of the video */
                    tagsOneOf?: components["parameters"]["tagsOneOf"];
                    /** @description tag(s) of the video, where all should be present in the video */
                    tagsAllOf?: components["parameters"]["tagsAllOf"];
                    /** @description **PeerTube >= 4.0** Display only local or remote objects */
                    isLocal?: components["parameters"]["isLocal"];
                    /** @description **Only administrators and moderators can use this parameter**
                     *
                     *     Include additional videos in results (can be combined using bitwise or operator)
                     *     - `0` NONE
                     *     - `1` NOT_PUBLISHED_STATE
                     *     - `2` BLACKLISTED
                     *     - `4` BLOCKED_OWNER
                     *     - `8` FILES
                     *     - `16` CAPTIONS
                     *     - `32` VIDEO SOURCE
                     *      */
                    include?: components["parameters"]["include"];
                    /** @description **PeerTube >= 4.0** Display only videos that have HLS files */
                    hasHLSFiles?: components["parameters"]["hasHLSFiles"];
                    /** @description **PeerTube >= 6.0** Display only videos that have Web Video files */
                    hasWebVideoFiles?: components["parameters"]["hasWebVideoFiles"];
                    /** @description Find elements owned by this host */
                    host?: components["parameters"]["host"];
                    /** @description **PeerTube >= 6.2** **Admins and moderators only** filter on videos that contain one of these automatic tags */
                    autoTagOneOf?: components["parameters"]["autoTagOneOfVideo"];
                    /** @description **PeerTube >= 4.0** Display only videos in this specific privacy/privacies */
                    privacyOneOf?: components["parameters"]["privacyOneOf"];
                    /** @description Whether or not to exclude videos that are in the user's video history */
                    excludeAlreadyWatched?: components["parameters"]["excludeAlreadyWatched"];
                    /** @description Plain text search, applied to various parts of the model depending on endpoint */
                    search?: components["parameters"]["search"];
                };
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description successful operation */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["VideoListResponse"];
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/users/me/subscriptions/{subscriptionHandle}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get subscription of my user */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    /** @description The subscription handle */
                    subscriptionHandle: components["parameters"]["subscriptionHandle"];
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description successful operation */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["VideoChannel"];
                    };
                };
            };
        };
        put?: never;
        post?: never;
        /** Delete subscription of my user */
        delete: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    /** @description The subscription handle */
                    subscriptionHandle: components["parameters"]["subscriptionHandle"];
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description successful operation */
                204: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/users/me/notifications": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List my notifications */
        get: {
            parameters: {
                query?: {
                    /** @description only list notifications of these types */
                    typeOneOf?: components["schemas"]["NotificationType"][];
                    /** @description only list unread notifications */
                    unread?: boolean;
                    /** @description Offset used to paginate results */
                    start?: components["parameters"]["start"];
                    /** @description Number of items to return */
                    count?: components["parameters"]["count"];
                    /** @description Sort column */
                    sort?: components["parameters"]["sort"];
                };
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description successful operation */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["NotificationListResponse"];
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/users/me/notifications/read": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Mark notifications as read by their id */
        post: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": {
                        /** @description ids of the notifications to mark as read */
                        ids: number[];
                    };
                };
            };
            responses: {
                /** @description successful operation */
                204: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/users/me/notifications/read-all": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Mark all my notification as read */
        post: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description successful operation */
                204: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/users/me/notification-settings": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        /** Update my notification settings */
        put: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": {
                        abuseAsModerator?: components["schemas"]["NotificationSettingValue"];
                        videoAutoBlacklistAsModerator?: components["schemas"]["NotificationSettingValue"];
                        newUserRegistration?: components["schemas"]["NotificationSettingValue"];
                        newVideoFromSubscription?: components["schemas"]["NotificationSettingValue"];
                        blacklistOnMyVideo?: components["schemas"]["NotificationSettingValue"];
                        myVideoPublished?: components["schemas"]["NotificationSettingValue"];
                        myVideoImportFinished?: components["schemas"]["NotificationSettingValue"];
                        commentMention?: components["schemas"]["NotificationSettingValue"];
                        newCommentOnMyVideo?: components["schemas"]["NotificationSettingValue"];
                        newFollow?: components["schemas"]["NotificationSettingValue"];
                        newInstanceFollower?: components["schemas"]["NotificationSettingValue"];
                        autoInstanceFollowing?: components["schemas"]["NotificationSettingValue"];
                        abuseStateChange?: components["schemas"]["NotificationSettingValue"];
                        abuseNewMessage?: components["schemas"]["NotificationSettingValue"];
                        newPeerTubeVersion?: components["schemas"]["NotificationSettingValue"];
                        newPluginVersion?: components["schemas"]["NotificationSettingValue"];
                        myVideoStudioEditionFinished?: components["schemas"]["NotificationSettingValue"];
                        myVideoTranscriptionGenerated?: components["schemas"]["NotificationSettingValue"];
                    };
                };
            };
            responses: {
                /** @description successful operation */
                204: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/users/me/history/videos": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List watched videos history */
        get: {
            parameters: {
                query?: {
                    /** @description Offset used to paginate results */
                    start?: components["parameters"]["start"];
                    /** @description Number of items to return */
                    count?: components["parameters"]["count"];
                    /** @description Plain text search, applied to various parts of the model depending on endpoint */
                    search?: components["parameters"]["search"];
                };
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description successful operation */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["VideoListResponse"];
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/users/me/history/videos/{videoId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        /** Delete history element */
        delete: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    videoId: components["schemas"]["Video"]["id"];
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description successful operation */
                204: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/users/me/history/videos/remove": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Clear video history */
        post: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "multipart/form-data": {
                        /**
                         * Format: date-time
                         * @description history before this date will be deleted
                         */
                        beforeDate?: string;
                    };
                };
            };
            responses: {
                /** @description successful operation */
                204: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/users/me/avatar/pick": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Update my user avatar */
        post: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "multipart/form-data": {
                        /**
                         * Format: binary
                         * @description The file to upload
                         */
                        avatarfile?: string;
                    };
                };
            };
            responses: {
                /** @description successful operation */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": {
                            avatars?: components["schemas"]["ActorImage"][];
                        };
                    };
                };
                /** @description image file too large */
                413: {
                    headers: {
                        /** @description Maximum file size for the avatar */
                        "X-File-Maximum-Size"?: string;
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/users/me/avatar": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        /** Delete my avatar */
        delete: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description successful operation */
                204: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/users/register": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Register a user
         * @description Signup has to be enabled and signup approval is not required
         */
        post: operations["registerUser"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/users/registrations/request": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Request registration
         * @description Signup has to be enabled and require approval on the instance
         */
        post: operations["requestRegistration"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/users/registrations/{registrationId}/accept": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Accept registration */
        post: operations["acceptRegistration"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/users/registrations/{registrationId}/reject": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Reject registration */
        post: operations["rejectRegistration"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/users/registrations/{registrationId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        /**
         * Delete registration
         * @description Delete the registration entry. It will not remove the user associated with this registration (if any)
         */
        delete: operations["deleteRegistration"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/users/registrations": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List registrations */
        get: operations["listRegistrations"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/videos/ownership": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List video ownership changes */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description successful operation */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/videos/ownership/{id}/accept": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Accept ownership change request */
        post: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    /** @description The object id, uuid or short uuid */
                    id: components["parameters"]["idOrUUID"];
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description successful operation */
                204: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                /** @description cannot terminate an ownership change of another user */
                403: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                /** @description video ownership change not found */
                404: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/videos/ownership/{id}/refuse": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Refuse ownership change request */
        post: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    /** @description The object id, uuid or short uuid */
                    id: components["parameters"]["idOrUUID"];
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description successful operation */
                204: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                /** @description cannot terminate an ownership change of another user */
                403: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                /** @description video ownership change not found */
                404: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/videos/{id}/give-ownership": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Request ownership change */
        post: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    /** @description The object id, uuid or short uuid */
                    id: components["parameters"]["idOrUUID"];
                };
                cookie?: never;
            };
            requestBody: {
                content: {
                    "application/json": {
                        username: string;
                    };
                };
            };
            responses: {
                /** @description successful operation */
                204: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                /** @description changing video ownership to a remote account is not supported yet */
                400: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                /** @description video not found */
                404: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/videos/{id}/token": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Request video token
         * @description Request special tokens that expire quickly to use them in some context (like accessing private static files)
         */
        post: operations["requestVideoToken"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/videos/{id}/studio/edit": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Create a studio task
         * @description Create a task to edit a video  (cut, add intro/outro etc)
         */
        post: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    /** @description The object id, uuid or short uuid */
                    id: components["parameters"]["idOrUUID"];
                };
                cookie?: never;
            };
            requestBody: {
                content: {
                    "multipart/form-data": components["schemas"]["VideoStudioCreateTask"];
                };
            };
            responses: {
                /** @description successful operation */
                204: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                /** @description incorrect parameters */
                400: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                /** @description video not found */
                404: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/videos": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List videos */
        get: operations["getVideos"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/videos/categories": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List available video categories */
        get: operations["getCategories"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/videos/licences": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List available video licences */
        get: operations["getLicences"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/videos/languages": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List available video languages */
        get: operations["getLanguages"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/videos/privacies": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List available video privacy policies */
        get: operations["getVideoPrivacyPolicies"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/videos/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get a video */
        get: operations["getVideo"];
        /** Update a video */
        put: operations["putVideo"];
        post?: never;
        /** Delete a video */
        delete: operations["delVideo"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/videos/{id}/description": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get complete video description */
        get: operations["getVideoDesc"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/videos/{id}/views": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Notify user is watching a video
         * @description Call this endpoint regularly (every 5-10 seconds for example) to notify the server the user is watching the video. After a while, PeerTube will increase video's viewers counter. If the user is authenticated, PeerTube will also store the current player time.
         */
        post: operations["addView"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/videos/{id}/watching": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        /**
         * Set watching progress of a video
         * @deprecated
         * @description This endpoint has been deprecated. Use `/videos/{id}/views` instead
         */
        put: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    /** @description The object id, uuid or short uuid */
                    id: components["parameters"]["idOrUUID"];
                };
                cookie?: never;
            };
            requestBody: {
                content: {
                    "application/json": components["schemas"]["UserViewingVideo"];
                };
            };
            responses: {
                /** @description successful operation */
                204: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/videos/{id}/stats/overall": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get overall stats of a video */
        get: {
            parameters: {
                query?: {
                    /** @description Filter stats by start date */
                    startDate?: string;
                    /** @description Filter stats by end date */
                    endDate?: string;
                };
                header?: never;
                path: {
                    /** @description The object id, uuid or short uuid */
                    id: components["parameters"]["idOrUUID"];
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description successful operation */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["VideoStatsOverall"];
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/videos/{id}/stats/user-agent": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get user agent stats of a video */
        get: {
            parameters: {
                query?: {
                    /** @description Filter stats by start date */
                    startDate?: string;
                    /** @description Filter stats by end date */
                    endDate?: string;
                };
                header?: never;
                path: {
                    /** @description The object id, uuid or short uuid */
                    id: components["parameters"]["idOrUUID"];
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description successful operation */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["VideoStatsUserAgent"];
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/videos/{id}/stats/retention": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get retention stats of a video */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    /** @description The object id, uuid or short uuid */
                    id: components["parameters"]["idOrUUID"];
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description successful operation */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["VideoStatsRetention"];
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/videos/{id}/stats/timeseries/{metric}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get timeserie stats of a video */
        get: {
            parameters: {
                query?: {
                    /** @description Filter stats by start date */
                    startDate?: string;
                    /** @description Filter stats by end date */
                    endDate?: string;
                };
                header?: never;
                path: {
                    /** @description The object id, uuid or short uuid */
                    id: components["parameters"]["idOrUUID"];
                    /** @description The metric to get */
                    metric: "viewers" | "aggregateWatchTime";
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description successful operation */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["VideoStatsTimeserie"];
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/videos/upload": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Upload a video
         * @description Uses a single request to upload a video.
         */
        post: operations["uploadLegacy"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/videos/upload-resumable": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        /**
         * Send chunk for the resumable upload of a video
         * @description Uses [a resumable protocol](https://github.com/kukhariev/node-uploadx/blob/master/proto.md) to continue, pause or resume the upload of a video
         */
        put: operations["uploadResumable"];
        /**
         * Initialize the resumable upload of a video
         * @description Uses [a resumable protocol](https://github.com/kukhariev/node-uploadx/blob/master/proto.md) to initialize the upload of a video
         */
        post: operations["uploadResumableInit"];
        /**
         * Cancel the resumable upload of a video, deleting any data uploaded so far
         * @description Uses [a resumable protocol](https://github.com/kukhariev/node-uploadx/blob/master/proto.md) to cancel the upload of a video
         */
        delete: operations["uploadResumableCancel"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/videos/imports": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Import a video
         * @description Import a torrent or magnetURI or HTTP resource (if enabled by the instance administrator)
         */
        post: operations["importVideo"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/videos/imports/{id}/cancel": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Cancel video import
         * @description Cancel a pending video import
         */
        post: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    /** @description Entity id */
                    id: components["parameters"]["id"];
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description successful operation */
                204: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/videos/imports/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        /**
         * Delete video import
         * @description Delete ended video import
         */
        delete: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    /** @description Entity id */
                    id: components["parameters"]["id"];
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description successful operation */
                204: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/videos/live": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Create a live */
        post: operations["addLive"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/videos/live/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get information about a live */
        get: operations["getLiveId"];
        /** Update information about a live */
        put: operations["updateLiveId"];
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/videos/live/{id}/sessions": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List live sessions
         * @description List all sessions created in a particular live
         */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    /** @description The object id, uuid or short uuid */
                    id: components["parameters"]["idOrUUID"];
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description successful operation */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": {
                            /** @example 1 */
                            total?: number;
                            data?: components["schemas"]["LiveVideoSessionResponse"][];
                        };
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/videos/{id}/live-session": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get live session of a replay
         * @description If the video is a replay of a live, you can find the associated live session using this endpoint
         */
        get: {
            parameters: {
                query?: never;
                header?: {
                    /** @description Required on password protected video */
                    "x-peertube-video-password"?: components["parameters"]["videoPasswordHeader"];
                };
                path: {
                    /** @description The object id, uuid or short uuid */
                    id: components["parameters"]["idOrUUID"];
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description successful operation */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["LiveVideoSessionResponse"];
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/videos/{id}/source": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get video source file metadata
         * @description Get metadata and download link of original video file
         */
        get: operations["getVideoSource"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/videos/{id}/source/file": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        /** Delete video source file */
        delete: operations["deleteVideoSourceFile"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/videos/{id}/source/replace-resumable": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        /**
         * Send chunk for the resumable replacement of a video
         * @description **PeerTube >= 6.0** Uses [a resumable protocol](https://github.com/kukhariev/node-uploadx/blob/master/proto.md) to continue, pause or resume the replacement of a video
         */
        put: operations["replaceVideoSourceResumable"];
        /**
         * Initialize the resumable replacement of a video
         * @description **PeerTube >= 6.0** Uses [a resumable protocol](https://github.com/kukhariev/node-uploadx/blob/master/proto.md) to initialize the replacement of a video
         */
        post: operations["replaceVideoSourceResumableInit"];
        /**
         * Cancel the resumable replacement of a video
         * @description **PeerTube >= 6.0** Uses [a resumable protocol](https://github.com/kukhariev/node-uploadx/blob/master/proto.md) to cancel the replacement of a video
         */
        delete: operations["replaceVideoSourceResumableCancel"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/users/me/abuses": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List my abuses */
        get: operations["getMyAbuses"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/abuses": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List abuses */
        get: operations["getAbuses"];
        put?: never;
        /** Report an abuse */
        post: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody: {
                content: {
                    "application/json": {
                        /** @description Reason why the user reports this video */
                        reason: string;
                        predefinedReasons?: components["schemas"]["PredefinedAbuseReasons"];
                        video?: {
                            /** @description Video id to report */
                            id?: components["schemas"]["Video"]["id"];
                            /**
                             * Format: seconds
                             * @description Timestamp in the video that marks the beginning of the report
                             */
                            startAt?: number;
                            /**
                             * Format: seconds
                             * @description Timestamp in the video that marks the ending of the report
                             */
                            endAt?: number;
                        };
                        comment?: {
                            /** @description Comment id to report */
                            id?: components["schemas"]["VideoComment"]["id"];
                        };
                        account?: {
                            /** @description Account id to report */
                            id?: number;
                        };
                    };
                };
            };
            responses: {
                /** @description successful operation */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": {
                            abuse?: {
                                id?: components["schemas"]["id"];
                            };
                        };
                    };
                };
                /** @description incorrect request parameters */
                400: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/abuses/{abuseId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        /** Update an abuse */
        put: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    /** @description Abuse id */
                    abuseId: components["parameters"]["abuseId"];
                };
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": {
                        state?: components["schemas"]["AbuseStateSet"];
                        /** @description Update the report comment visible only to the moderation team */
                        moderationComment?: string;
                    };
                };
            };
            responses: {
                /** @description successful operation */
                204: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                /** @description abuse not found */
                404: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        post?: never;
        /** Delete an abuse */
        delete: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    /** @description Abuse id */
                    abuseId: components["parameters"]["abuseId"];
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description successful operation */
                204: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                /** @description block not found */
                404: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/abuses/{abuseId}/messages": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List messages of an abuse */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    /** @description Abuse id */
                    abuseId: components["parameters"]["abuseId"];
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description successful operation */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": {
                            /** @example 1 */
                            total?: number;
                            data?: components["schemas"]["AbuseMessage"][];
                        };
                    };
                };
            };
        };
        put?: never;
        /** Add message to an abuse */
        post: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    /** @description Abuse id */
                    abuseId: components["parameters"]["abuseId"];
                };
                cookie?: never;
            };
            requestBody: {
                content: {
                    "application/json": {
                        /** @description Message to send */
                        message: string;
                    };
                };
            };
            responses: {
                /** @description successful operation */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                /** @description incorrect request parameters */
                400: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/abuses/{abuseId}/messages/{abuseMessageId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        /** Delete an abuse message */
        delete: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    /** @description Abuse id */
                    abuseId: components["parameters"]["abuseId"];
                    /** @description Abuse message id */
                    abuseMessageId: components["parameters"]["abuseMessageId"];
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description successful operation */
                204: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/videos/{id}/blacklist": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Block a video */
        post: operations["addVideoBlock"];
        /** Unblock a video by its id */
        delete: operations["delVideoBlock"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/videos/blacklist": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List video blocks */
        get: operations["getVideoBlocks"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/videos/{id}/storyboards": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List storyboards of a video
         * @description **PeerTube >= 6.0**
         */
        get: operations["listVideoStoryboards"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/videos/{id}/captions": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List captions of a video */
        get: operations["getVideoCaptions"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/videos/{id}/captions/generate": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Generate a video caption
         * @description **PeerTube >= 6.2** This feature has to be enabled by the administrator
         */
        post: operations["generateVideoCaption"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/videos/{id}/captions/{captionLanguage}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        /** Add or replace a video caption */
        put: operations["addVideoCaption"];
        post?: never;
        /** Delete a video caption */
        delete: operations["delVideoCaption"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/videos/{id}/chapters": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get chapters of a video
         * @description **PeerTube >= 6.0**
         */
        get: operations["getVideoChapters"];
        /**
         * Replace video chapters
         * @description **PeerTube >= 6.0**
         */
        put: operations["replaceVideoChapters"];
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/videos/{id}/passwords": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List video passwords
         * @description **PeerTube >= 6.0**
         */
        get: {
            parameters: {
                query?: {
                    /** @description Offset used to paginate results */
                    start?: components["parameters"]["start"];
                    /** @description Number of items to return */
                    count?: components["parameters"]["count"];
                    /** @description Sort column */
                    sort?: components["parameters"]["sort"];
                };
                header?: never;
                path: {
                    /** @description The object id, uuid or short uuid */
                    id: components["parameters"]["idOrUUID"];
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description successful operation */
                204: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["VideoPasswordList"];
                    };
                };
                /** @description video is not password protected */
                400: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        /**
         * Update video passwords
         * @description **PeerTube >= 6.0**
         */
        put: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    /** @description The object id, uuid or short uuid */
                    id: components["parameters"]["idOrUUID"];
                };
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": {
                        passwords?: components["schemas"]["AddVideoPasswords"];
                    };
                };
            };
            responses: {
                /** @description successful operation */
                204: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                /** @description video is not password protected */
                400: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/videos/{id}/passwords/{videoPasswordId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        /**
         * Delete a video password
         * @description **PeerTube >= 6.0**
         */
        delete: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    /** @description The object id, uuid or short uuid */
                    id: components["parameters"]["idOrUUID"];
                    /** @description The video password id */
                    videoPasswordId: components["parameters"]["videoPasswordId"];
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description successful operation */
                204: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                /** @description video is not password protected */
                400: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                /** @description cannot delete the last password of the protected video */
                403: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/video-channels": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List video channels */
        get: operations["getVideoChannels"];
        put?: never;
        /** Create a video channel */
        post: operations["addVideoChannel"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/video-channels/{channelHandle}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get a video channel */
        get: operations["getVideoChannel"];
        /** Update a video channel */
        put: operations["putVideoChannel"];
        post?: never;
        /** Delete a video channel */
        delete: operations["delVideoChannel"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/video-channels/{channelHandle}/videos": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List videos of a video channel */
        get: operations["getVideoChannelVideos"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/video-channels/{channelHandle}/video-playlists": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List playlists of a channel */
        get: {
            parameters: {
                query?: {
                    /** @description Offset used to paginate results */
                    start?: components["parameters"]["start"];
                    /** @description Number of items to return */
                    count?: components["parameters"]["count"];
                    /** @description Sort column */
                    sort?: components["parameters"]["sort"];
                    playlistType?: components["parameters"]["videoPlaylistType"];
                };
                header?: never;
                path: {
                    /** @description The video channel handle */
                    channelHandle: components["parameters"]["channelHandle"];
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description successful operation */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": {
                            /** @example 1 */
                            total?: number;
                            data?: components["schemas"]["VideoPlaylist"][];
                        };
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/video-channels/{channelHandle}/followers": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List followers of a video channel */
        get: operations["getVideoChannelFollowers"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/video-channels/{channelHandle}/avatar/pick": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Update channel avatar */
        post: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    /** @description The video channel handle */
                    channelHandle: components["parameters"]["channelHandle"];
                };
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "multipart/form-data": {
                        /**
                         * Format: binary
                         * @description The file to upload.
                         */
                        avatarfile?: string;
                    };
                };
            };
            responses: {
                /** @description successful operation */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": {
                            avatars?: components["schemas"]["ActorImage"][];
                        };
                    };
                };
                /** @description image file too large */
                413: {
                    headers: {
                        /** @description Maximum file size for the avatar */
                        "X-File-Maximum-Size"?: string;
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/video-channels/{channelHandle}/avatar": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        /** Delete channel avatar */
        delete: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    /** @description The video channel handle */
                    channelHandle: components["parameters"]["channelHandle"];
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description successful operation */
                204: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/video-channels/{channelHandle}/banner/pick": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Update channel banner */
        post: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    /** @description The video channel handle */
                    channelHandle: components["parameters"]["channelHandle"];
                };
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "multipart/form-data": {
                        /**
                         * Format: binary
                         * @description The file to upload.
                         */
                        bannerfile?: string;
                    };
                };
            };
            responses: {
                /** @description successful operation */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": {
                            banners?: components["schemas"]["ActorImage"][];
                        };
                    };
                };
                /** @description image file too large */
                413: {
                    headers: {
                        /** @description Maximum file size for the banner */
                        "X-File-Maximum-Size"?: string;
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/video-channels/{channelHandle}/banner": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        /** Delete channel banner */
        delete: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    /** @description The video channel handle */
                    channelHandle: components["parameters"]["channelHandle"];
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description successful operation */
                204: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/video-channels/{channelHandle}/import-videos": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Import videos in channel
         * @description Import a remote channel/playlist videos into a channel
         */
        post: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    /** @description The video channel handle */
                    channelHandle: components["parameters"]["channelHandle"];
                };
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": components["schemas"]["ImportVideosInChannelCreate"];
                };
            };
            responses: {
                /** @description successful operation */
                204: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/video-channel-syncs": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Create a synchronization for a video channel */
        post: operations["addVideoChannelSync"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/video-channel-syncs/{channelSyncId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        /** Delete a video channel synchronization */
        delete: operations["delVideoChannelSync"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/video-channel-syncs/{channelSyncId}/sync": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Triggers the channel synchronization job, fetching all the videos from the remote channel */
        post: operations["triggerVideoChannelSync"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/video-playlists/privacies": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List available playlist privacy policies */
        get: operations["getPlaylistPrivacyPolicies"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/video-playlists": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List video playlists */
        get: operations["getPlaylists"];
        put?: never;
        /**
         * Create a video playlist
         * @description If the video playlist is set as public, `videoChannelId` is mandatory.
         */
        post: operations["addPlaylist"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/video-playlists/{playlistId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get a video playlist */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    /** @description Playlist id */
                    playlistId: components["parameters"]["playlistId"];
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description successful operation */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["VideoPlaylist"];
                    };
                };
            };
        };
        /**
         * Update a video playlist
         * @description If the video playlist is set as public, the playlist must have a assigned channel.
         */
        put: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    /** @description Playlist id */
                    playlistId: components["parameters"]["playlistId"];
                };
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "multipart/form-data": {
                        /** @description Video playlist display name */
                        displayName?: string;
                        /**
                         * Format: binary
                         * @description Video playlist thumbnail file
                         */
                        thumbnailfile?: string;
                        privacy?: components["schemas"]["VideoPlaylistPrivacySet"];
                        /** @description Video playlist description */
                        description?: string;
                        /** @description Video channel in which the playlist will be published */
                        videoChannelId?: components["schemas"]["id"];
                    };
                };
            };
            responses: {
                /** @description successful operation */
                204: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        post?: never;
        /** Delete a video playlist */
        delete: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    /** @description Playlist id */
                    playlistId: components["parameters"]["playlistId"];
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description successful operation */
                204: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/video-playlists/{playlistId}/videos": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List videos of a playlist */
        get: operations["getVideoPlaylistVideos"];
        put?: never;
        /** Add a video in a playlist */
        post: operations["addVideoPlaylistVideo"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/video-playlists/{playlistId}/videos/reorder": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Reorder a playlist */
        post: operations["reorderVideoPlaylist"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/video-playlists/{playlistId}/videos/{playlistElementId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        /** Update a playlist element */
        put: operations["putVideoPlaylistVideo"];
        post?: never;
        /** Delete an element from a playlist */
        delete: operations["delVideoPlaylistVideo"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/users/me/video-playlists/videos-exist": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Check video exists in my playlists */
        get: {
            parameters: {
                query: {
                    /** @description The video ids to check */
                    videoIds: components["schemas"]["Video"]["id"][];
                };
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description successful operation */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": {
                            videoId?: {
                                playlistElementId?: number;
                                playlistId?: number;
                                /** Format: seconds */
                                startTimestamp?: number | null;
                                /** Format: seconds */
                                stopTimestamp?: number | null;
                            }[];
                        };
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/accounts/{name}/video-playlists": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List playlists of an account */
        get: {
            parameters: {
                query?: {
                    /** @description Offset used to paginate results */
                    start?: components["parameters"]["start"];
                    /** @description Number of items to return */
                    count?: components["parameters"]["count"];
                    /** @description Sort column */
                    sort?: components["parameters"]["sort"];
                    /** @description Plain text search, applied to various parts of the model depending on endpoint */
                    search?: components["parameters"]["search"];
                    playlistType?: components["parameters"]["videoPlaylistType"];
                };
                header?: never;
                path: {
                    /** @description The username or handle of the account */
                    name: components["parameters"]["name"];
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description successful operation */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": {
                            /** @example 1 */
                            total?: number;
                            data?: components["schemas"]["VideoPlaylist"][];
                        };
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/accounts/{name}/video-channels": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List video channels of an account */
        get: {
            parameters: {
                query?: {
                    /** @description include daily view statistics for the last 30 days and total views (only if authentified as the account user) */
                    withStats?: boolean;
                    /** @description Offset used to paginate results */
                    start?: components["parameters"]["start"];
                    /** @description Number of items to return */
                    count?: components["parameters"]["count"];
                    /** @description Sort column */
                    sort?: components["parameters"]["sort"];
                };
                header?: never;
                path: {
                    /** @description The username or handle of the account */
                    name: components["parameters"]["name"];
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description successful operation */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["VideoChannelList"];
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/accounts/{name}/video-channel-syncs": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List the synchronizations of video channels of an account */
        get: {
            parameters: {
                query?: {
                    /** @description Offset used to paginate results */
                    start?: components["parameters"]["start"];
                    /** @description Number of items to return */
                    count?: components["parameters"]["count"];
                    /** @description Sort column */
                    sort?: components["parameters"]["sort"];
                };
                header?: never;
                path: {
                    /** @description The username or handle of the account */
                    name: components["parameters"]["name"];
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description successful operation */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["VideoChannelSyncList"];
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/accounts/{name}/ratings": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List ratings of an account */
        get: {
            parameters: {
                query?: {
                    /** @description Offset used to paginate results */
                    start?: components["parameters"]["start"];
                    /** @description Number of items to return */
                    count?: components["parameters"]["count"];
                    /** @description Sort column */
                    sort?: components["parameters"]["sort"];
                    /** @description Optionally filter which ratings to retrieve */
                    rating?: "like" | "dislike";
                };
                header?: never;
                path: {
                    /** @description The username or handle of the account */
                    name: components["parameters"]["name"];
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description successful operation */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["VideoRating"][];
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/videos/{id}/comment-threads": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List threads of a video */
        get: {
            parameters: {
                query?: {
                    /** @description Offset used to paginate results */
                    start?: components["parameters"]["start"];
                    /** @description Number of items to return */
                    count?: components["parameters"]["count"];
                    /** @description Sort comments by criteria */
                    sort?: components["parameters"]["commentsSort"];
                };
                header?: {
                    /** @description Required on password protected video */
                    "x-peertube-video-password"?: components["parameters"]["videoPasswordHeader"];
                };
                path: {
                    /** @description The object id, uuid or short uuid */
                    id: components["parameters"]["idOrUUID"];
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description successful operation */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["CommentThreadResponse"];
                    };
                };
            };
        };
        put?: never;
        /** Create a thread */
        post: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    /** @description The object id, uuid or short uuid */
                    id: components["parameters"]["idOrUUID"];
                };
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": {
                        /** Format: markdown */
                        text: components["schemas"]["VideoComment"]["text"];
                    };
                };
            };
            responses: {
                /** @description successful operation */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["CommentThreadPostResponse"];
                    };
                };
                /** @description video does not exist */
                404: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/videos/{id}/comment-threads/{threadId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get a thread */
        get: {
            parameters: {
                query?: never;
                header?: {
                    /** @description Required on password protected video */
                    "x-peertube-video-password"?: components["parameters"]["videoPasswordHeader"];
                };
                path: {
                    /** @description The object id, uuid or short uuid */
                    id: components["parameters"]["idOrUUID"];
                    /** @description The thread id (root comment id) */
                    threadId: components["parameters"]["threadId"];
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description successful operation */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["VideoCommentThreadTree"];
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/videos/comments": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List instance comments */
        get: {
            parameters: {
                query?: {
                    /** @description Plain text search, applied to various parts of the model depending on endpoint */
                    search?: components["parameters"]["search"];
                    /** @description Filter comments by searching on the account */
                    searchAccount?: components["parameters"]["searchAccountForComments"];
                    /** @description Filter comments by searching on the video */
                    searchVideo?: components["parameters"]["searchVideoForComments"];
                    /** @description Limit results on this specific video */
                    videoId?: components["parameters"]["videoId"];
                    /** @description Limit results on this specific video channel */
                    videoChannelId?: components["parameters"]["videoChannelId"];
                    /** @description **PeerTube >= 6.2** filter on comments that contain one of these automatic tags */
                    autoTagOneOf?: components["parameters"]["autoTagOneOfComment"];
                    /** @description **PeerTube >= 4.0** Display only local or remote objects */
                    isLocal?: components["parameters"]["isLocal"];
                    /** @description Display only objects of local or remote videos */
                    onLocalVideo?: components["parameters"]["onLocalVideo"];
                };
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description successful operation */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": {
                            /** @example 1 */
                            total?: number;
                            data?: components["schemas"]["VideoCommentForOwnerOrAdmin"][];
                        };
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/videos/{id}/comments/{commentId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Reply to a thread of a video */
        post: {
            parameters: {
                query?: never;
                header?: {
                    /** @description Required on password protected video */
                    "x-peertube-video-password"?: components["parameters"]["videoPasswordHeader"];
                };
                path: {
                    /** @description The object id, uuid or short uuid */
                    id: components["parameters"]["idOrUUID"];
                    /** @description The comment id */
                    commentId: components["parameters"]["commentId"];
                };
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": {
                        /** Format: markdown */
                        text: components["schemas"]["VideoComment"]["text"];
                    };
                };
            };
            responses: {
                /** @description successful operation */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["CommentThreadPostResponse"];
                    };
                };
                /** @description thread or video does not exist */
                404: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        /** Delete a comment or a reply */
        delete: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    /** @description The object id, uuid or short uuid */
                    id: components["parameters"]["idOrUUID"];
                    /** @description The comment id */
                    commentId: components["parameters"]["commentId"];
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description successful operation */
                204: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                /** @description cannot remove comment of another user */
                403: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                /** @description comment or video does not exist */
                404: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                /** @description comment is already deleted */
                409: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/videos/{id}/comments/{commentId}/approve": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Approve a comment
         * @description **PeerTube >= 6.2** Approve a comment that requires a review
         */
        post: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    /** @description The object id, uuid or short uuid */
                    id: components["parameters"]["idOrUUID"];
                    /** @description The comment id */
                    commentId: components["parameters"]["commentId"];
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description successful operation */
                204: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/videos/{id}/rate": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        /** Like/dislike a video */
        put: {
            parameters: {
                query?: never;
                header?: {
                    /** @description Required on password protected video */
                    "x-peertube-video-password"?: components["parameters"]["videoPasswordHeader"];
                };
                path: {
                    /** @description The object id, uuid or short uuid */
                    id: components["parameters"]["idOrUUID"];
                };
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": {
                        /** @enum {string} */
                        rating: "like" | "dislike";
                    };
                };
            };
            responses: {
                /** @description successful operation */
                204: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                /** @description video does not exist */
                404: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/videos/{id}/hls": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        /** Delete video HLS files */
        delete: operations["delVideoHLS"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/videos/{id}/web-videos": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        /**
         * Delete video Web Video files
         * @description **PeerTube >= 6.0**
         */
        delete: operations["delVideoWebVideos"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/videos/{id}/transcoding": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Create a transcoding job */
        post: operations["createVideoTranscoding"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/search/videos": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Search videos */
        get: operations["searchVideos"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/search/video-channels": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Search channels */
        get: operations["searchChannels"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/search/video-playlists": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Search playlists */
        get: operations["searchPlaylists"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/blocklist/status": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get block status of accounts/hosts */
        get: {
            parameters: {
                query?: {
                    /**
                     * @description Check if these accounts are blocked
                     * @example [
                     *       "goofy@example.com",
                     *       "donald@example.com"
                     *     ]
                     */
                    accounts?: string[];
                    /**
                     * @description Check if these hosts are blocked
                     * @example [
                     *       "example.com"
                     *     ]
                     */
                    hosts?: string[];
                };
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description successful operation */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["BlockStatus"];
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/server/blocklist/accounts": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List account blocks */
        get: {
            parameters: {
                query?: {
                    /** @description Offset used to paginate results */
                    start?: components["parameters"]["start"];
                    /** @description Number of items to return */
                    count?: components["parameters"]["count"];
                    /** @description Sort column */
                    sort?: components["parameters"]["sort"];
                };
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description successful operation */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        put?: never;
        /** Block an account */
        post: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": {
                        /**
                         * @description account to block, in the form `username@domain`
                         * @example chocobozzz@example.org
                         */
                        accountName: string;
                    };
                };
            };
            responses: {
                /** @description successful operation */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                /** @description self-blocking forbidden */
                409: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/server/blocklist/accounts/{accountName}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        /** Unblock an account by its handle */
        delete: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    /** @description account to unblock, in the form `username@domain` */
                    accountName: string;
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description successful operation */
                201: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                /** @description account or account block does not exist */
                404: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/server/blocklist/servers": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List server blocks */
        get: {
            parameters: {
                query?: {
                    /** @description Offset used to paginate results */
                    start?: components["parameters"]["start"];
                    /** @description Number of items to return */
                    count?: components["parameters"]["count"];
                    /** @description Sort column */
                    sort?: components["parameters"]["sort"];
                };
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description successful operation */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        put?: never;
        /** Block a server */
        post: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": {
                        /**
                         * Format: hostname
                         * @description server domain to block
                         */
                        host: string;
                    };
                };
            };
            responses: {
                /** @description successful operation */
                204: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                /** @description self-blocking forbidden */
                409: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/server/blocklist/servers/{host}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        /** Unblock a server by its domain */
        delete: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    /** @description server domain to unblock */
                    host: string;
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description successful operation */
                204: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                /** @description account block does not exist */
                404: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/server/redundancy/{host}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        /** Update a server redundancy policy */
        put: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    /** @description server domain to mirror */
                    host: string;
                };
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": {
                        /** @description allow mirroring of the host's local videos */
                        redundancyAllowed: boolean;
                    };
                };
            };
            responses: {
                /** @description successful operation */
                204: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                /** @description server is not already known */
                404: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/server/redundancy/videos": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List videos being mirrored */
        get: operations["getMirroredVideos"];
        put?: never;
        /** Mirror a video */
        post: operations["putMirroredVideo"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/server/redundancy/videos/{redundancyId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        /** Delete a mirror done on a video */
        delete: operations["delMirroredVideo"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/server/stats": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get instance stats
         * @description Get instance public statistics. This endpoint is cached.
         */
        get: operations["getInstanceStats"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/server/logs/client": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Send client log */
        post: operations["sendClientLog"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/server/logs": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get instance logs */
        get: operations["getInstanceLogs"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/server/audit-logs": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get instance audit logs */
        get: operations["getInstanceAuditLogs"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/plugins": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List plugins */
        get: operations["getPlugins"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/plugins/available": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List available plugins */
        get: operations["getAvailablePlugins"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/plugins/install": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Install a plugin */
        post: operations["addPlugin"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/plugins/update": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Update a plugin */
        post: operations["updatePlugin"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/plugins/uninstall": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Uninstall a plugin */
        post: operations["uninstallPlugin"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/plugins/{npmName}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get a plugin */
        get: operations["getPlugin"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/plugins/{npmName}/settings": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        /** Set a plugin's settings */
        put: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    /** @description name of the plugin/theme on npmjs.com or in its package.json */
                    npmName: components["parameters"]["npmName"];
                };
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": {
                        settings?: {
                            [key: string]: unknown;
                        };
                    };
                };
            };
            responses: {
                /** @description successful operation */
                204: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                /** @description plugin not found */
                404: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/plugins/{npmName}/public-settings": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get a plugin's public settings */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    /** @description name of the plugin/theme on npmjs.com or in its package.json */
                    npmName: components["parameters"]["npmName"];
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description successful operation */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": {
                            [key: string]: unknown;
                        };
                    };
                };
                /** @description plugin not found */
                404: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/plugins/{npmName}/registered-settings": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get a plugin's registered settings */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    /** @description name of the plugin/theme on npmjs.com or in its package.json */
                    npmName: components["parameters"]["npmName"];
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description successful operation */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": {
                            [key: string]: unknown;
                        };
                    };
                };
                /** @description plugin not found */
                404: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/metrics/playback": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Create playback metrics
         * @description These metrics are exposed by OpenTelemetry metrics exporter if enabled.
         */
        post: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": components["schemas"]["PlaybackMetricCreate"];
                };
            };
            responses: {
                /** @description successful operation */
                204: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/runners/registration-tokens/generate": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Generate registration token
         * @description Generate a new runner registration token
         */
        post: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description successful operation */
                204: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/runners/registration-tokens/{registrationTokenId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        /**
         * Remove registration token
         * @description Remove a registration token. Runners that used this token for their registration are automatically removed.
         */
        delete: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    registrationTokenId: components["parameters"]["registrationTokenId"];
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description successful operation */
                204: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/runners/registration-tokens": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List registration tokens */
        get: {
            parameters: {
                query?: {
                    /** @description Offset used to paginate results */
                    start?: components["parameters"]["start"];
                    /** @description Number of items to return */
                    count?: components["parameters"]["count"];
                    /** @description Sort registration tokens by criteria */
                    sort?: components["parameters"]["registrationTokenSort"];
                };
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description successful operation */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": {
                            /** @example 1 */
                            total?: number;
                            data?: components["schemas"]["RunnerRegistrationToken"][];
                        };
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/runners/register": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Register a new runner
         * @description API used by PeerTube runners
         */
        post: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": {
                        registrationToken: string;
                        name: string;
                        description?: string;
                    };
                };
            };
            responses: {
                /** @description successful operation */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": {
                            /** @description Runner id */
                            id?: number;
                            runnerToken?: string;
                        };
                    };
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/runners/unregister": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Unregister a runner
         * @description API used by PeerTube runners
         */
        post: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": {
                        runnerToken: string;
                    };
                };
            };
            responses: {
                /** @description successful operation */
                204: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/runners/{runnerId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        /** Delete a runner */
        delete: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    runnerId: components["parameters"]["runnerId"];
                };
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": {
                        runnerToken: string;
                    };
                };
            };
            responses: {
                /** @description successful operation */
                204: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/runners": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List runners */
        get: {
            parameters: {
                query?: {
                    /** @description Offset used to paginate results */
                    start?: components["parameters"]["start"];
                    /** @description Number of items to return */
                    count?: components["parameters"]["count"];
                    /** @description Sort runners by criteria */
                    sort?: components["parameters"]["runnerSort"];
                };
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description successful operation */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": {
                            /** @example 1 */
                            total?: number;
                            data?: components["schemas"]["Runner"][];
                        };
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/runners/jobs/request": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Request a new job
         * @description API used by PeerTube runners
         */
        post: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": {
                        runnerToken: string;
                        /** @description Filter jobs depending on their types */
                        jobTypes?: string[];
                    };
                };
            };
            responses: {
                /** @description successful operation */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": {
                            availableJobs?: {
                                uuid?: components["schemas"]["UUIDv4"];
                                type?: components["schemas"]["RunnerJobType"];
                                payload?: components["schemas"]["RunnerJobPayload"];
                            }[];
                        };
                    };
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/runners/jobs/{jobUUID}/accept": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Accept job
         * @description API used by PeerTube runners
         */
        post: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    jobUUID: components["parameters"]["jobUUID"];
                };
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": {
                        runnerToken: string;
                    };
                };
            };
            responses: {
                /** @description successful operation */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": {
                            job?: components["schemas"]["RunnerJob"] & {
                                jobToken?: string;
                            };
                        };
                    };
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/runners/jobs/{jobUUID}/abort": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Abort job
         * @description API used by PeerTube runners
         */
        post: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    jobUUID: components["parameters"]["jobUUID"];
                };
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": {
                        runnerToken: string;
                        jobToken: string;
                        /** @description Why the runner aborts this job */
                        reason: string;
                    };
                };
            };
            responses: {
                /** @description successful operation */
                204: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/runners/jobs/{jobUUID}/update": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Update job
         * @description API used by PeerTube runners
         */
        post: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    jobUUID: components["parameters"]["jobUUID"];
                };
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": {
                        runnerToken: string;
                        jobToken: string;
                        /** @description Update job progression percentage (optional) */
                        progress?: number;
                        payload?: {
                            /** @enum {string} */
                            type?: "add-chunk" | "remove-chunk";
                            /** Format: binary */
                            masterPlaylistFile?: string;
                            /** Format: binary */
                            resolutionPlaylistFile?: string;
                            resolutionPlaylistFilename?: string;
                            /** Format: binary */
                            videoChunkFile?: string;
                            videoChunkFilename?: string;
                        };
                    };
                };
            };
            responses: {
                /** @description successful operation */
                204: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/runners/jobs/{jobUUID}/error": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Post job error
         * @description API used by PeerTube runners
         */
        post: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    jobUUID: components["parameters"]["jobUUID"];
                };
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": {
                        runnerToken: string;
                        jobToken: string;
                        /** @description Why the runner failed to process this job */
                        message: string;
                    };
                };
            };
            responses: {
                /** @description successful operation */
                204: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/runners/jobs/{jobUUID}/success": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Post job success
         * @description API used by PeerTube runners
         */
        post: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    jobUUID: components["parameters"]["jobUUID"];
                };
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": {
                        runnerToken: string;
                        jobToken: string;
                        payload: {
                            /** Format: binary */
                            videoFile?: string;
                        } | {
                            /** Format: binary */
                            videoFile?: string;
                            /** Format: binary */
                            resolutionPlaylistFile?: string;
                        } | {
                            /** Format: binary */
                            videoFile?: string;
                        } | Record<string, never>;
                    };
                };
            };
            responses: {
                /** @description successful operation */
                204: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/runners/jobs/{jobUUID}/cancel": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Cancel a job */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    jobUUID: components["parameters"]["jobUUID"];
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description successful operation */
                204: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/runners/jobs/{jobUUID}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        /**
         * Delete a job
         * @description The endpoint will first cancel the job if needed, and then remove it from the database. Children jobs will also be removed
         */
        delete: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    jobUUID: components["parameters"]["jobUUID"];
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description successful operation */
                204: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/runners/jobs": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List jobs */
        get: {
            parameters: {
                query?: {
                    /** @description Offset used to paginate results */
                    start?: components["parameters"]["start"];
                    /** @description Number of items to return */
                    count?: components["parameters"]["count"];
                    /** @description Sort runner jobs by criteria */
                    sort?: components["parameters"]["runnerJobSort"];
                    /** @description Plain text search, applied to various parts of the model depending on endpoint */
                    search?: components["parameters"]["search"];
                    stateOneOf?: components["schemas"]["RunnerJobState"][];
                };
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description successful operation */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": {
                            /** @example 1 */
                            total?: number;
                            data?: components["schemas"]["RunnerJobAdmin"][];
                        };
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/automatic-tags/policies/accounts/{accountName}/comments": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get account auto tag policies on comments
         * @description **PeerTube >= 6.2**
         */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    /** @description account name to get auto tag policies */
                    accountName: string;
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description successful operation */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["CommentAutoTagPolicies"];
                    };
                };
            };
        };
        /**
         * Update account auto tag policies on comments
         * @description **PeerTube >= 6.2**
         */
        put: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    /** @description account name to update auto tag policies */
                    accountName: string;
                };
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": {
                        /** @description Auto tags that automatically set the comment in review state */
                        review?: string[];
                    };
                };
            };
            responses: {
                /** @description successful operation */
                204: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/automatic-tags/accounts/{accountName}/available": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get account available auto tags
         * @description **PeerTube >= 6.2**
         */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    /** @description account name to get auto tag policies */
                    accountName: string;
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description successful operation */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["AutomaticTagAvailable"];
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/automatic-tags/server/available": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get server available auto tags
         * @description **PeerTube >= 6.2**
         */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description successful operation */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["AutomaticTagAvailable"];
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/watched-words/accounts/{accountName}/lists": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List account watched words
         * @description **PeerTube >= 6.2**
         */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    /** @description account name to list watched words */
                    accountName: string;
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description successful operation */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": {
                            /** @example 1 */
                            total?: number;
                            data?: components["schemas"]["WatchedWordsLists"][];
                        };
                    };
                };
            };
        };
        put?: never;
        /**
         * Add account watched words
         * @description **PeerTube >= 6.2**
         */
        post: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    accountName: string;
                };
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": {
                        listName?: string;
                        words?: string[];
                    };
                };
            };
            responses: {
                /** @description successful operation */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": {
                            watchedWordsList?: {
                                id?: number;
                            };
                        };
                    };
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/watched-words/accounts/{accountName}/lists/{listId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        /**
         * Update account watched words
         * @description **PeerTube >= 6.2**
         */
        put: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    accountName: string;
                    /** @description list of watched words to update */
                    listId: string;
                };
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": {
                        listName?: string;
                        words?: string[];
                    };
                };
            };
            responses: {
                /** @description successful operation */
                204: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        post?: never;
        /**
         * Delete account watched words
         * @description **PeerTube >= 6.2**
         */
        delete: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    accountName: string;
                    /** @description list of watched words to delete */
                    listId: string;
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description successful operation */
                204: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/watched-words/server/lists": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List server watched words
         * @description **PeerTube >= 6.2**
         */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description successful operation */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": {
                            /** @example 1 */
                            total?: number;
                            data?: components["schemas"]["WatchedWordsLists"][];
                        };
                    };
                };
            };
        };
        put?: never;
        /**
         * Add server watched words
         * @description **PeerTube >= 6.2**
         */
        post: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": {
                        listName?: string;
                        words?: string[];
                    };
                };
            };
            responses: {
                /** @description successful operation */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": {
                            watchedWordsList?: {
                                id?: number;
                            };
                        };
                    };
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/watched-words/server/lists/{listId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        /**
         * Update server watched words
         * @description **PeerTube >= 6.2**
         */
        put: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    /** @description list of watched words to update */
                    listId: string;
                };
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": {
                        listName?: string;
                        words?: string[];
                    };
                };
            };
            responses: {
                /** @description successful operation */
                204: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        post?: never;
        /**
         * Delete server watched words
         * @description **PeerTube >= 6.2**
         */
        delete: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    /** @description list of watched words to delete */
                    listId: string;
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description successful operation */
                204: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
}
export type webhooks = Record<string, never>;
export interface components {
    schemas: {
        /** @example 42 */
        id: number;
        /**
         * Format: uuid
         * @example 9c9de5e8-0a1e-484a-b099-e80766180a6d
         */
        UUIDv4: string;
        /**
         * @description translation of a uuid v4 with a bigger alphabet to have a shorter uuid
         * @example 2y84q2MQUMWPbiEcxNXMgC
         */
        shortUUID: string;
        /**
         * @description immutable name of the user, used to find or mention its actor
         * @example chocobozzz
         */
        username: string;
        /**
         * @description immutable name of the channel, used to interact with its actor
         * @example framasoft_videos
         */
        usernameChannel: string;
        /** Format: password */
        password: string;
        /**
         * @description category id of the video (see [/videos/categories](#operation/getCategories))
         * @example 15
         */
        VideoCategorySet: number;
        "VideoConstantNumber-Category": {
            id?: components["schemas"]["VideoCategorySet"];
            /** @example Science & Technology */
            label?: string;
        };
        /**
         * @description licence id of the video (see [/videos/licences](#operation/getLicences))
         * @example 2
         */
        VideoLicenceSet: number;
        "VideoConstantNumber-Licence": {
            id?: components["schemas"]["VideoLicenceSet"];
            /** @example Attribution - Share Alike */
            label?: string;
        };
        /**
         * @description language id of the video (see [/videos/languages](#operation/getLanguages))
         * @example en
         */
        VideoLanguageSet: string;
        "VideoConstantString-Language": {
            id?: components["schemas"]["VideoLanguageSet"];
            /** @example English */
            label?: string;
        };
        /**
         * @description Video playlist privacy policy (see [/video-playlists/privacies](#operation/getPlaylistPrivacyPolicies))
         * @enum {integer}
         */
        VideoPlaylistPrivacySet: 1 | 2 | 3;
        VideoPlaylistPrivacyConstant: {
            id?: components["schemas"]["VideoPlaylistPrivacySet"];
            label?: string;
        };
        /**
         * @description The video playlist type (Regular = `1`, Watch Later = `2`)
         * @enum {integer}
         */
        VideoPlaylistTypeSet: 1 | 2;
        VideoPlaylistTypeConstant: {
            id?: components["schemas"]["VideoPlaylistTypeSet"];
            label?: string;
        };
        /**
         * @description privacy id of the video (see [/videos/privacies](#operation/getVideoPrivacyPolicies))
         * @enum {integer}
         */
        VideoPrivacySet: 1 | 2 | 3 | 4 | 5;
        VideoPrivacyConstant: {
            id?: components["schemas"]["VideoPrivacySet"];
            label?: string;
        };
        /**
         * @description Comments policy of the video (Enabled = `1`, Disabled = `2`, Requires Approval = `3`)
         * @enum {integer}
         */
        VideoCommentsPolicySet: 1 | 2 | 3;
        VideoCommentsPolicyConstant: {
            id?: components["schemas"]["VideoCommentsPolicySet"];
            label?: string;
        };
        BlockStatus: {
            accounts?: {
                [key: string]: {
                    blockedByServer?: boolean;
                    blockedByUser?: boolean;
                };
            };
            hosts?: {
                [key: string]: {
                    blockedByServer?: boolean;
                    blockedByUser?: boolean;
                };
            };
        };
        /** @enum {string} */
        NSFWPolicy: "display" | "warn" | "do_not_list";
        /**
         * @description
         *     NSFW flags (can be combined using bitwise or operator)
         *     - `0` NONE
         *     - `1` VIOLENT
         *     - `2` EXPLICIT_SEX
         *
         * @enum {integer}
         */
        NSFWFlag: 0 | 1 | 2 | 4;
        /**
         * @description The user role (Admin = `0`, Moderator = `1`, User = `2`)
         * @example 2
         * @enum {integer}
         */
        UserRole: 0 | 1 | 2;
        /**
         * @description Admin flags for the user (None = `0`, Bypass video blocklist = `1`)
         * @example 1
         * @enum {integer}
         */
        UserAdminFlags: 0 | 1;
        /**
         * @description The live latency mode (Default = `1`, High latency = `2`, Small Latency = `3`)
         * @enum {integer}
         */
        LiveVideoLatencyMode: 1 | 2 | 3;
        LiveVideoReplaySettings: {
            privacy?: components["schemas"]["VideoPrivacySet"];
        };
        VideoStateConstant: {
            /**
             * @description The video state:
             *     - `1`: Published
             *     - `2`: To transcode
             *     - `3`: To import
             *     - `4`: Waiting for live stream
             *     - `5`: Live ended
             *     - `6`: To move to an external storage (object storage...)
             *     - `7`: Transcoding failed
             *     - `8`: Moving to an external storage failed
             *     - `9`: To edit using studio edition feature
             *
             * @enum {integer}
             */
            id?: 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9;
            label?: string;
        };
        /**
         * @description The user export state:
         *       - `1`: Pending
         *       - `2`: Processing
         *       - `3`: Completed
         *       - `4`: Errored
         *
         * @enum {integer}
         */
        UserExportState: 1 | 2 | 3 | 4;
        /**
         * @description The user import state:
         *       - `1`: Pending
         *       - `2`: Processing
         *       - `3`: Completed
         *       - `4`: Errored
         *
         * @enum {integer}
         */
        UserImportState: 1 | 2 | 3 | 4;
        /**
         * @description The abuse state (Pending = `1`, Rejected = `2`, Accepted = `3`)
         * @enum {integer}
         */
        AbuseStateSet: 1 | 2 | 3;
        AbuseStateConstant: {
            id?: components["schemas"]["AbuseStateSet"];
            label?: string;
        };
        /** @example [
         *       "spamOrMisleading"
         *     ] */
        AbusePredefinedReasons: ("violentOrAbusive" | "hatefulOrAbusive" | "spamOrMisleading" | "privacy" | "rights" | "serverRules" | "thumbnails" | "captions")[];
        /**
         * @description Video resolution (`0`, `240`, `360`, `720`, `1080`, `1440` or `2160`)
         *
         *     `0` is used as a special value for stillimage videos dedicated to audio, a.k.a. audio-only videos.
         *
         * @example 240
         */
        VideoResolutionSet: number;
        /** @description resolutions and their labels for the video */
        VideoResolutionConstant: {
            id?: components["schemas"]["VideoResolutionSet"];
            /** @example 240p */
            label?: string;
        };
        VideoScheduledUpdate: {
            privacy?: components["schemas"]["VideoPrivacySet"];
            /**
             * Format: date-time
             * @description When to update the video
             */
            updateAt: string;
        };
        AccountSummary: {
            id?: number;
            name?: string;
            displayName?: string;
            /** Format: url */
            url?: string;
            /** Format: hostname */
            host?: string;
            avatars?: components["schemas"]["ActorImage"][];
        };
        VideoChannelSummary: {
            id?: components["schemas"]["id"];
            name?: string;
            displayName?: string;
            /** Format: url */
            url?: string;
            /** Format: hostname */
            host?: string;
            avatars?: components["schemas"]["ActorImage"][];
        };
        PlaylistElement: {
            position?: number;
            /** Format: seconds */
            startTimestamp?: number;
            /** Format: seconds */
            stopTimestamp?: number;
            video?: components["schemas"]["Video"] | null;
        };
        VideoFile: {
            id?: components["schemas"]["id"];
            /**
             * Format: uri
             * @description magnet URI allowing to resolve the video via BitTorrent without a metainfo file
             */
            magnetUri?: string;
            resolution?: components["schemas"]["VideoResolutionConstant"];
            /** @description Video file size in bytes */
            size?: number;
            /**
             * Format: url
             * @description Direct URL of the torrent file
             */
            torrentUrl?: string;
            /**
             * Format: url
             * @description URL endpoint that transfers the torrent file as an attachment (so that the browser opens a download dialog)
             */
            torrentDownloadUrl?: string;
            /**
             * Format: url
             * @description Direct URL of the video
             */
            fileUrl?: string;
            /**
             * Format: url
             * @description Playlist URL of the file if it is owned by a playlist
             */
            playlistUrl?: string;
            /**
             * Format: url
             * @description URL endpoint that transfers the video file as an attachment (so that the browser opens a download dialog)
             */
            fileDownloadUrl?: string;
            /** @description Frames per second of the video file */
            fps?: number;
            /** @description **PeerTube >= 6.1** Video stream width */
            width?: number;
            /** @description **PeerTube >= 6.1** Video stream height */
            height?: number;
            /**
             * Format: url
             * @description URL dereferencing the output of ffprobe on the file
             */
            metadataUrl?: string;
            /** @description **PeerTube >= 6.2** The file container has an audio stream */
            hasAudio?: boolean;
            /** @description **PeerTube >= 6.2** The file container has a video stream */
            hasVideo?: boolean;
            storage?: components["schemas"]["FileStorage"];
        };
        VideoStreamingPlaylists: {
            id?: components["schemas"]["id"];
            /**
             * @description Playlist type:
             *     - `1`: HLS
             *
             * @enum {integer}
             */
            type?: 1;
        } & components["schemas"]["VideoStreamingPlaylists-HLS"];
        "VideoStreamingPlaylists-HLS": {
            /** Format: url */
            playlistUrl?: string;
            /** Format: url */
            segmentsSha256Url?: string;
            /** @description Video files associated to this playlist.
             *
             *     The difference with the root `files` property is that these files are fragmented, so they can be used in this streaming playlist (HLS, etc.)
             *      */
            files?: components["schemas"]["VideoFile"][];
            redundancies?: {
                /** Format: url */
                baseUrl?: string;
            }[];
        };
        VideoInfo: {
            id?: components["schemas"]["Video"]["id"];
            uuid?: components["schemas"]["Video"]["uuid"];
            name?: components["schemas"]["Video"]["name"];
            state?: components["schemas"]["Video"]["state"];
        };
        Video: {
            /** @description object id for the video */
            id?: components["schemas"]["id"];
            /** @description universal identifier for the video, that can be used across instances */
            uuid?: components["schemas"]["UUIDv4"];
            shortUUID?: components["schemas"]["shortUUID"];
            isLive?: boolean;
            /**
             * Format: date-time
             * @description time at which the video object was first drafted
             * @example 2017-10-01T10:52:46.396Z
             */
            createdAt?: string;
            /**
             * Format: date-time
             * @description time at which the video was marked as ready for playback (with restrictions depending on `privacy`). Usually set after a `state` evolution.
             * @example 2018-10-01T10:52:46.396Z
             */
            publishedAt?: string;
            /**
             * Format: date-time
             * @description last time the video's metadata was modified
             * @example 2021-05-04T08:01:01.502Z
             */
            updatedAt?: string;
            /**
             * Format: date-time
             * @description used to represent a date of first publication, prior to the practical publication date of `publishedAt`
             * @example 2010-10-01T10:52:46.396Z
             */
            originallyPublishedAt?: string | null;
            /** @description category in which the video is classified */
            category?: components["schemas"]["VideoConstantNumber-Category"];
            /** @description licence under which the video is distributed */
            licence?: components["schemas"]["VideoConstantNumber-Licence"];
            /** @description main language used in the video */
            language?: components["schemas"]["VideoConstantString-Language"];
            /** @description privacy policy used to distribute the video */
            privacy?: components["schemas"]["VideoPrivacyConstant"];
            /**
             * @description truncated description of the video, written in Markdown.
             *
             * @example **[Want to help to translate this video?](https://weblate.framasoft.org/projects/what-is-peertube-video/)**\r\n\r\n
             *     **Take back the control of your videos! [#JoinPeertube](https://joinpeertube.org)**\r\n*A decentralized video hosting network, based on fr...
             *
             */
            truncatedDescription?: string | null;
            /**
             * Format: seconds
             * @description duration of the video in seconds
             * @example 1419
             */
            duration?: number;
            /**
             * Format: float
             * @description **PeerTube >= 6.1** Aspect ratio of the video stream
             * @example 1.778
             */
            aspectRatio?: number | null;
            isLocal?: boolean;
            /**
             * @description title of the video
             * @example What is PeerTube?
             */
            name?: string;
            /** @example /lazy-static/thumbnails/a65bc12f-9383-462e-81ae-8207e8b434ee.jpg */
            thumbnailPath?: string;
            /** @example /lazy-static/previews/a65bc12f-9383-462e-81ae-8207e8b434ee.jpg */
            previewPath?: string;
            /** @example /videos/embed/a65bc12f-9383-462e-81ae-8207e8b434ee */
            embedPath?: string;
            /** @example 1337 */
            views?: number;
            /** @example 42 */
            likes?: number;
            /** @example 7 */
            dislikes?: number;
            /** @description **PeerTube >= 7.2** Number of comments on the video */
            comments?: number;
            nsfw?: boolean;
            nsfwFlags?: components["schemas"]["NSFWFlag"];
            /** @description **PeerTube >= 7.2** More information about the sensitive content of the video */
            nsfwSummary?: string;
            waitTranscoding?: boolean | null;
            /** @description represents the internal state of the video processing within the PeerTube instance */
            state?: components["schemas"]["VideoStateConstant"];
            scheduledUpdate?: components["schemas"]["VideoScheduledUpdate"] | null;
            blacklisted?: boolean | null;
            blacklistedReason?: string | null;
            account?: components["schemas"]["AccountSummary"];
            channel?: components["schemas"]["VideoChannelSummary"];
            userHistory?: {
                currentTime?: number;
            } | null;
        };
        VideoDetails: components["schemas"]["Video"] & {
            /** @description If the video is a live, you have the amount of current viewers */
            viewers?: number;
            /**
             * @description full description of the video, written in Markdown.
             *
             * @example "**[Want to help to translate this video?](https://weblate.framasoft.org/projects/what-is-peertube-video/)**\r\n\r\n
             *     **Take back the control of your videos! [#JoinPeertube](https://joinpeertube.org)**\r\n*A decentralized video hosting network,
             *     based on free/libre software!*\r\n\r\n**Animation Produced by:** [LILA](https://libreart.info) - [ZeMarmot Team](https://film.zemarmot.net)\r\n
             *     *Directed by* Aryeom\r\n*Assistant* Jehan\r\n**Licence**: [CC-By-SA 4.0](https://creativecommons.org/licenses/by-sa/4.0/)\r\n\r\n
             *     **Sponsored by** [Framasoft](https://framasoft.org)\r\n\r\n**Music**: [Red Step Forward](http://play.dogmazic.net/song.php?song_id=52491) - CC-By Ken Bushima\r\n\r\n
             *     **Movie Clip**: [Caminades 3: Llamigos](http://www.caminandes.com/) CC-By Blender Institute\r\n\r\n**Video sources**: https://gitlab.gnome.org/Jehan/what-is-peertube/"
             *
             */
            description?: string | null;
            /**
             * @description A text tell the audience how to support the video creator
             * @example Please support our work on https://soutenir.framasoft.org/en/ <3
             */
            support?: string | null;
            channel?: components["schemas"]["VideoChannel"];
            account?: components["schemas"]["Account"];
            /** @example [
             *       "flowers",
             *       "gardening"
             *     ] */
            tags?: string[];
            /**
             * @deprecated
             * @description Deprecated in 6.2, use commentsPolicy instead
             */
            commentsEnabled?: boolean;
            commentsPolicy?: components["schemas"]["VideoCommentsPolicyConstant"];
            downloadEnabled?: boolean;
            /**
             * Format: date-time
             * @description Latest input file update. Null if the file has never been replaced since the original upload
             */
            inputFileUpdatedAt?: string | null;
            /** @example [
             *       "https://peertube2.cpy.re/tracker/announce",
             *       "wss://peertube2.cpy.re/tracker/socket"
             *     ] */
            trackerUrls?: string[];
            /** @description Web compatible video files. If Web Video is disabled on the server:
             *
             *     - field will be empty
             *     - video files will be found in `streamingPlaylists[].files` field
             *      */
            files?: components["schemas"]["VideoFile"][];
            /** @description HLS playlists/manifest files. If HLS is disabled on the server:
             *
             *     - field will be empty
             *     - video files will be found in `files` field
             *      */
            streamingPlaylists?: components["schemas"]["VideoStreamingPlaylists"][];
        };
        FileRedundancyInformation: {
            id?: components["schemas"]["id"];
            /** Format: url */
            fileUrl?: string;
            /** @enum {string} */
            strategy?: "manual" | "most-views" | "trending" | "recently-added";
            size?: number;
            /** Format: date-time */
            createdAt?: string;
            /** Format: date-time */
            updatedAt?: string;
            /** Format: date-time */
            expiresOn?: string;
        };
        VideoRedundancy: {
            id?: components["schemas"]["id"];
            name?: string;
            /** Format: url */
            url?: string;
            uuid?: components["schemas"]["UUIDv4"];
            redundancies?: {
                streamingPlaylists?: components["schemas"]["FileRedundancyInformation"][];
            };
        };
        CommentAutoTagPolicies: {
            /** @description Auto tags that automatically set the comment in review state */
            review?: string[];
        };
        AutomaticTagAvailable: {
            /** @description Available auto tags that can be used to filter objects or set a comment in review state */
            available?: {
                /** @description tag name */
                name?: string;
                /** @enum {string} */
                type?: "core" | "watched-words-list";
            }[];
        };
        VideoImportStateConstant: {
            /**
             * @description The video import state (Pending = `1`, Success = `2`, Failed = `3`)
             * @enum {integer}
             */
            id?: 1 | 2 | 3;
            /** @example Pending */
            label?: string;
        };
        VideoCreateImport: ({
            targetUrl: components["schemas"]["VideoImport"]["targetUrl"];
        } | {
            magnetUri: components["schemas"]["VideoImport"]["magnetUri"];
        } | {
            torrentfile: components["schemas"]["VideoImport"]["torrentfile"];
        }) & WithRequired<components["schemas"]["VideoUploadRequestCommon"], "channelId" | "name">;
        VideoImport: {
            readonly id?: components["schemas"]["id"];
            /**
             * Format: url
             * @description remote URL where to find the import's source video
             * @example https://framatube.org/videos/watch/9c9de5e8-0a1e-484a-b099-e80766180a6d
             */
            targetUrl?: string;
            /**
             * Format: uri
             * @description magnet URI allowing to resolve the import's source video
             */
            magnetUri?: string;
            /**
             * Format: binary
             * @description Torrent file containing only the video file
             */
            torrentfile?: string;
            readonly torrentName?: string;
            readonly state?: components["schemas"]["VideoImportStateConstant"];
            readonly error?: string;
            /** Format: date-time */
            readonly createdAt?: string;
            /** Format: date-time */
            readonly updatedAt?: string;
            readonly video?: components["schemas"]["Video"] | null;
        };
        VideoImportsList: {
            /** @example 1 */
            total?: number;
            data?: components["schemas"]["VideoImport"][];
        };
        Abuse: {
            id?: components["schemas"]["id"];
            /** @example The video is a spam */
            reason?: string;
            predefinedReasons?: components["schemas"]["AbusePredefinedReasons"];
            reporterAccount?: components["schemas"]["Account"];
            state?: components["schemas"]["AbuseStateConstant"];
            /** @example Decided to ban the server since it spams us regularly */
            moderationComment?: string;
            video?: {
                id?: number;
                uuid?: components["schemas"]["UUIDv4"];
                shortUUID?: components["schemas"]["shortUUID"];
                name?: string;
                nsfw?: boolean;
                /** Format: date-time */
                startAt?: string;
                /** Format: date-time */
                endAt?: string;
                deleted?: boolean;
                blacklisted?: boolean;
                thumbnailPath?: string;
                channel?: components["schemas"]["VideoChannel"];
            };
            /** Format: date-time */
            createdAt?: string;
        };
        AbuseMessage: {
            id?: components["schemas"]["id"];
            message?: string;
            byModerator?: boolean;
            /** Format: date-time */
            createdAt?: string;
            account?: components["schemas"]["AccountSummary"];
        };
        VideoBlacklist: {
            id?: components["schemas"]["id"];
            videoId?: components["schemas"]["Video"]["id"];
            /** Format: date-time */
            createdAt?: string;
            /** Format: date-time */
            updatedAt?: string;
            name?: string;
            uuid?: components["schemas"]["UUIDv4"];
            description?: string;
            duration?: number;
            views?: number;
            likes?: number;
            dislikes?: number;
            nsfw?: boolean;
        };
        VideoPlaylist: {
            id?: components["schemas"]["id"];
            uuid?: components["schemas"]["UUIDv4"];
            shortUUID?: components["schemas"]["shortUUID"];
            /** Format: date-time */
            createdAt?: string;
            /** Format: date-time */
            updatedAt?: string;
            description?: string;
            displayName?: string;
            isLocal?: boolean;
            videoLength?: number;
            thumbnailPath?: string;
            privacy?: components["schemas"]["VideoPlaylistPrivacyConstant"];
            type?: components["schemas"]["VideoPlaylistTypeConstant"];
            ownerAccount?: components["schemas"]["AccountSummary"];
            videoChannel?: components["schemas"]["VideoChannelSummary"];
        };
        VideoComment: {
            id?: components["schemas"]["id"];
            /** Format: url */
            url?: string;
            /**
             * Format: html
             * @description Text of the comment
             * @example This video is wonderful!
             */
            text?: string;
            threadId?: components["schemas"]["id"];
            inReplyToCommentId?: components["schemas"]["id"] | null;
            videoId?: components["schemas"]["Video"]["id"];
            /** Format: date-time */
            createdAt?: string;
            /** Format: date-time */
            updatedAt?: string;
            /**
             * Format: date-time
             * @default null
             */
            deletedAt: string | null;
            /** @default false */
            isDeleted: boolean;
            heldForReview?: boolean;
            totalRepliesFromVideoAuthor?: number;
            totalReplies?: number;
            account?: components["schemas"]["Account"];
        };
        VideoCommentThreadTree: {
            comment?: components["schemas"]["VideoComment"];
            children?: components["schemas"]["VideoCommentThreadTree"][];
        };
        VideoCommentForOwnerOrAdmin: {
            id?: components["schemas"]["id"];
            url?: components["schemas"]["VideoComment"]["url"];
            text?: components["schemas"]["VideoComment"]["text"];
            heldForReview?: components["schemas"]["VideoComment"]["heldForReview"];
            threadId?: components["schemas"]["VideoComment"]["threadId"];
            inReplyToCommentId?: components["schemas"]["VideoComment"]["inReplyToCommentId"];
            createdAt?: components["schemas"]["VideoComment"]["createdAt"];
            updatedAt?: components["schemas"]["VideoComment"]["updatedAt"];
            account?: components["schemas"]["VideoComment"]["account"];
            video?: components["schemas"]["VideoInfo"];
            automaticTags?: string[];
        };
        Storyboard: {
            storyboardPath?: string;
            totalHeight?: number;
            totalWidth?: number;
            spriteHeight?: number;
            spriteWidth?: number;
            spriteDuration?: number;
        };
        VideoCaption: {
            language?: components["schemas"]["VideoConstantString-Language"];
            captionPath?: string;
        };
        VideoChapters: {
            chapters?: {
                title?: string;
                timecode?: number;
            };
        };
        VideoSource: {
            /**
             * @deprecated
             * @description Deprecated in 6.1, use inputFilename instead
             */
            filename?: string;
            /** @description Uploaded/imported filename */
            inputFilename?: string;
            /** @description **PeerTube >= 6.1** If enabled by the admin, the video source file is kept on the server and can be downloaded by the owner */
            fileDownloadUrl?: string;
            /** @description **PeerTube >= 6.1** */
            resolution?: components["schemas"]["VideoResolutionConstant"];
            /** @description **PeerTube >= 6.1** Video file size in bytes */
            size?: number;
            /** @description **PeerTube >= 6.1** Frames per second of the video file */
            fps?: number;
            /** @description **PeerTube >= 6.1** Video stream width */
            width?: number;
            /** @description **PeerTube >= 6.1** Video stream height */
            height?: number;
            /** Format: date-time */
            createdAt?: string;
        };
        ActorImage: {
            path?: string;
            width?: number;
            /** Format: date-time */
            createdAt?: string;
            /** Format: date-time */
            updatedAt?: string;
        };
        ActorInfo: {
            id?: components["schemas"]["id"];
            name?: string;
            displayName?: string;
            /** Format: hostname */
            host?: string;
            avatars?: components["schemas"]["ActorImage"][];
        };
        Actor: {
            id?: components["schemas"]["id"];
            /** Format: url */
            url?: string;
            /** @description immutable name of the actor, used to find or mention it */
            name?: components["schemas"]["username"];
            avatars?: components["schemas"]["ActorImage"][];
            /**
             * Format: hostname
             * @description server on which the actor is resident
             */
            host?: string;
            /** @description whether this actor's host allows redundancy of its videos */
            hostRedundancyAllowed?: boolean | null;
            /** @description number of actors subscribed to by this actor, as seen by this instance */
            followingCount?: number;
            /** @description number of followers of this actor, as seen by this instance */
            followersCount?: number;
            /** Format: date-time */
            createdAt?: string;
            /** Format: date-time */
            updatedAt?: string;
        };
        Account: components["schemas"]["Actor"] & {
            /** @description object id for the user tied to this account */
            userId?: components["schemas"]["User"]["id"] | null;
            /** @description editable name of the account, displayed in its representations */
            displayName?: string;
            /** @description text or bio displayed on the account's profile */
            description?: string | null;
        };
        UserViewingVideo: {
            /**
             * Format: seconds
             * @description timestamp within the video, in seconds
             * @example 5
             */
            currentTime: number;
            /**
             * @description Event since last viewing call:
             *      * `seek` - If the user seeked the video
             *
             * @enum {string}
             */
            viewEvent?: "seek";
            /** @description Optional param to represent the current viewer session. Used by the backend to properly count one view per session per video. PeerTube admin can configure the server to not trust this `sessionId` parameter but use the request IP address instead to identify a viewer.
             *      */
            sessionId?: string;
            /** @description Client software used to watch the video. For example "Firefox", "PeerTube Approval Android", etc.
             *      */
            client?: string;
            /** @description Device used to watch the video. For example "desktop", "mobile", "smarttv", etc.
             *      */
            device?: components["schemas"]["VideoStatsUserAgentDevice"];
            /** @description Operating system used to watch the video. For example "Windows", "Ubuntu", etc.
             *      */
            operatingSystem?: string;
        };
        VideoStatsOverall: {
            averageWatchTime?: number;
            totalWatchTime?: number;
            viewersPeak?: number;
            /** Format: date-time */
            viewersPeakDate?: string;
            countries?: {
                isoCode?: string;
                viewers?: number;
            }[];
        };
        /** @enum {unknown} */
        VideoStatsUserAgentDevice: "console" | "embedded" | "mobile" | "smarttv" | "tablet" | "wearable" | "xr" | "desktop";
        VideoStatsUserAgent: {
            clients?: {
                name?: string;
                viewers?: number;
            }[];
            devices?: {
                name?: components["schemas"]["VideoStatsUserAgentDevice"];
                viewers?: number;
            }[];
            operatingSystem?: {
                name?: string;
                viewers?: number;
            }[];
        };
        VideoStatsRetention: {
            data?: {
                second?: number;
                retentionPercent?: number;
            }[];
        };
        VideoStatsTimeserie: {
            data?: {
                date?: string;
                value?: number;
            }[];
        };
        ServerConfig: {
            instance?: {
                name?: string;
                shortDescription?: string;
                defaultClientRoute?: string;
                isNSFW?: boolean;
                defaultNSFWPolicy?: string;
                serverCountry?: string;
                support?: {
                    text?: string;
                };
                social?: {
                    externalLink?: string;
                    mastodonLink?: string;
                    blueskyLink?: string;
                };
                customizations?: {
                    javascript?: string;
                    css?: string;
                };
                avatars?: components["schemas"]["ActorImage"][];
                banners?: components["schemas"]["ActorImage"][];
            };
            search?: {
                remoteUri?: {
                    users?: boolean;
                    anonymous?: boolean;
                };
            };
            plugin?: {
                registered?: string[];
            };
            theme?: {
                registered?: string[];
            };
            email?: {
                enabled?: boolean;
            };
            contactForm?: {
                enabled?: boolean;
            };
            serverVersion?: string;
            serverCommit?: string;
            signup?: {
                allowed?: boolean;
                allowedForCurrentIP?: boolean;
                requiresEmailVerification?: boolean;
            };
            transcoding?: {
                hls?: {
                    enabled?: boolean;
                };
                web_videos?: {
                    enabled?: boolean;
                };
                enabledResolutions?: components["schemas"]["VideoResolutionSet"][];
            };
            import?: {
                videos?: {
                    http?: {
                        enabled?: boolean;
                    };
                    torrent?: {
                        enabled?: boolean;
                    };
                };
                videoChannelSynchronization?: {
                    enabled?: boolean;
                };
                users?: {
                    enabled?: boolean;
                };
            };
            export?: {
                users?: {
                    enabled?: boolean;
                    /** @description In milliseconds */
                    exportExpiration?: number;
                    /** @description In bytes */
                    maxUserVideoQuota?: number;
                };
            };
            autoBlacklist?: {
                videos?: {
                    ofUsers?: {
                        enabled?: boolean;
                    };
                };
            };
            avatar?: {
                file?: {
                    size?: {
                        max?: number;
                    };
                };
                extensions?: string[];
            };
            video?: {
                image?: {
                    extensions?: string[];
                    size?: {
                        max?: number;
                    };
                };
                file?: {
                    extensions?: string[];
                };
            };
            videoCaption?: {
                file?: {
                    size?: {
                        max?: number;
                    };
                    extensions?: string[];
                };
            };
            user?: {
                /**
                 * @description In bytes
                 * @example 16810141515
                 */
                videoQuota?: number;
                /**
                 * @description In bytes
                 * @example 1681014151
                 */
                videoQuotaDaily?: number;
            };
            trending?: {
                videos?: {
                    intervalDays?: number;
                };
            };
            tracker?: {
                enabled?: boolean;
            };
            followings?: {
                instance?: {
                    autoFollowIndex?: {
                        /** Format: url */
                        indexUrl?: string;
                    };
                };
            };
            federation?: {
                enabled?: boolean;
            };
            homepage?: {
                enabled?: boolean;
            };
            /** @description PeerTube >= 6.1 */
            openTelemetry?: {
                metrics?: {
                    enabled?: boolean;
                    /** @description Milliseconds */
                    playbackStatsInterval?: number;
                };
            };
            /** @description PeerTube >= 6.1 */
            views?: {
                views?: {
                    watchingInterval?: {
                        /** @description Milliseconds */
                        anonymous?: number;
                        /** @description Milliseconds */
                        users?: number;
                    };
                };
            };
        };
        SendClientLog: {
            message: string;
            /** @description URL of the current user page */
            url: string;
            /** @enum {unknown} */
            level: "error" | "warn";
            /** @description Stack trace of the error if there is one */
            stackTrace?: string;
            /** @description User agent of the web browser that sends the message */
            userAgent?: string;
            /** @description Additional information regarding this log */
            meta?: string;
        };
        ServerStats: {
            totalUsers?: number;
            totalDailyActiveUsers?: number;
            totalWeeklyActiveUsers?: number;
            totalMonthlyActiveUsers?: number;
            /** @description **PeerTube >= 6.1** Value is null if the admin disabled total moderators stats */
            totalModerators?: number;
            /** @description **PeerTube >= 6.1** Value is null if the admin disabled total admins stats */
            totalAdmins?: number;
            totalLocalVideos?: number;
            /** @description Total video views made on the instance */
            totalLocalVideoViews?: number;
            /** @description Total comments made by local users */
            totalLocalVideoComments?: number;
            totalLocalVideoFilesSize?: number;
            totalVideos?: number;
            totalVideoComments?: number;
            totalLocalVideoChannels?: number;
            totalLocalDailyActiveVideoChannels?: number;
            totalLocalWeeklyActiveVideoChannels?: number;
            totalLocalMonthlyActiveVideoChannels?: number;
            totalLocalPlaylists?: number;
            totalInstanceFollowers?: number;
            totalInstanceFollowing?: number;
            videosRedundancy?: {
                strategy?: string;
                totalSize?: number;
                totalUsed?: number;
                totalVideoFiles?: number;
                totalVideos?: number;
            }[];
            totalActivityPubMessagesProcessed?: number;
            totalActivityPubMessagesSuccesses?: number;
            totalActivityPubMessagesErrors?: number;
            activityPubMessagesProcessedPerSecond?: number;
            totalActivityPubMessagesWaiting?: number;
            /** @description **PeerTube >= 6.1** Value is null if the admin disabled registration requests stats */
            averageRegistrationRequestResponseTimeMs?: number;
            /** @description **PeerTube >= 6.1** Value is null if the admin disabled registration requests stats */
            totalRegistrationRequestsProcessed?: number;
            /** @description **PeerTube >= 6.1** Value is null if the admin disabled registration requests stats */
            totalRegistrationRequests?: number;
            /** @description **PeerTube >= 6.1** Value is null if the admin disabled abuses stats */
            averageAbuseResponseTimeMs?: number;
            /** @description **PeerTube >= 6.1** Value is null if the admin disabled abuses stats */
            totalAbusesProcessed?: number;
            /** @description **PeerTube >= 6.1** Value is null if the admin disabled abuses stats */
            totalAbuses?: number;
        };
        ServerConfigAbout: {
            instance?: {
                name?: string;
                shortDescription?: string;
                description?: string;
                terms?: string;
                codeOfConduct?: string;
                hardwareInformation?: string;
                creationReason?: string;
                moderationInformation?: string;
                administrator?: string;
                maintenanceLifetime?: string;
                businessModel?: string;
                languages?: string[];
                categories?: number[];
                avatars?: components["schemas"]["ActorImage"][];
                banners?: components["schemas"]["ActorImage"][];
            };
        };
        ServerConfigCustom: {
            instance?: {
                name?: string;
                shortDescription?: string;
                description?: string;
                terms?: string;
                codeOfConduct?: string;
                creationReason?: string;
                moderationInformation?: string;
                administrator?: string;
                maintenanceLifetime?: string;
                businessModel?: string;
                hardwareInformation?: string;
                languages?: string[];
                categories?: number[];
                isNSFW?: boolean;
                defaultNSFWPolicy?: string;
                serverCountry?: string;
                support?: {
                    text?: string;
                };
                social?: {
                    externalLink?: string;
                    mastodonLink?: string;
                    blueskyLink?: string;
                };
                defaultClientRoute?: string;
                customizations?: {
                    javascript?: string;
                    css?: string;
                };
            };
            theme?: {
                default?: string;
            };
            services?: {
                twitter?: {
                    username?: string;
                };
            };
            cache?: {
                previews?: {
                    size?: number;
                };
                captions?: {
                    size?: number;
                };
            };
            signup?: {
                enabled?: boolean;
                limit?: number;
                requiresEmailVerification?: boolean;
            };
            admin?: {
                /** Format: email */
                email?: string;
            };
            contactForm?: {
                enabled?: boolean;
            };
            /** @description Settings that apply to new users, if registration is enabled */
            user?: {
                /** @example 16810141515 */
                videoQuota?: number;
                /** @example 1681014151 */
                videoQuotaDaily?: number;
            };
            /** @description Settings pertaining to transcoding jobs */
            transcoding?: {
                enabled?: boolean;
                originalFile?: {
                    keep?: boolean;
                };
                /** @description Allow your users to upload .mkv, .mov, .avi, .wmv, .flv, .f4v, .3g2, .3gp, .mts, m2ts, .mxf, .nut videos */
                allowAdditionalExtensions?: boolean;
                /** @description If a user uploads an audio file, PeerTube will create a video by merging the preview file and the audio file */
                allowAudioFiles?: boolean;
                /** @description Amount of threads used by ffmpeg for 1 transcoding job */
                threads?: number;
                /** @description Amount of transcoding jobs to execute in parallel */
                concurrency?: number;
                /**
                 * @description New profiles can be added by plugins ; available in core PeerTube: 'default'.
                 *
                 * @enum {string}
                 */
                profile?: "default";
                /** @description Resolutions to transcode _new videos_ to */
                resolutions?: {
                    "0p"?: boolean;
                    "144p"?: boolean;
                    "240p"?: boolean;
                    "360p"?: boolean;
                    "480p"?: boolean;
                    "720p"?: boolean;
                    "1080p"?: boolean;
                    "1440p"?: boolean;
                    "2160p"?: boolean;
                };
                /** @description Web Video specific settings */
                web_videos?: {
                    enabled?: boolean;
                };
                /** @description HLS specific settings */
                hls?: {
                    enabled?: boolean;
                    splitAudioAndVideo?: boolean;
                };
            };
            import?: {
                videos?: {
                    http?: {
                        enabled?: boolean;
                    };
                    torrent?: {
                        enabled?: boolean;
                    };
                };
                video_channel_synchronization?: {
                    enabled?: boolean;
                };
            };
            autoBlacklist?: {
                videos?: {
                    ofUsers?: {
                        enabled?: boolean;
                    };
                };
            };
            followers?: {
                instance?: {
                    enabled?: boolean;
                    manualApproval?: boolean;
                };
            };
        };
        CustomHomepage: {
            content?: string;
        };
        Follow: {
            id?: components["schemas"]["id"];
            follower?: components["schemas"]["Actor"];
            following?: components["schemas"]["Actor"];
            /** @description score reflecting the reachability of the actor, with steps of `10` and a base score of `1000`. */
            score?: number;
            /** @enum {string} */
            state?: "pending" | "accepted";
            /** Format: date-time */
            createdAt?: string;
            /** Format: date-time */
            updatedAt?: string;
        };
        /** @description Reason categories that help triage reports */
        PredefinedAbuseReasons: ("violentOrAbusive" | "hatefulOrAbusive" | "spamOrMisleading" | "privacy" | "rights" | "serverRules" | "thumbnails" | "captions")[];
        Job: {
            id?: components["schemas"]["id"];
            /** @enum {string} */
            state?: "active" | "completed" | "failed" | "waiting" | "delayed";
            /** @enum {string} */
            type?: "activitypub-http-unicast" | "activitypub-http-broadcast" | "activitypub-http-fetcher" | "activitypub-follow" | "video-file-import" | "video-transcoding" | "email" | "video-import" | "videos-views-stats" | "activitypub-refresher" | "video-redundancy" | "video-channel-import";
            data?: {
                [key: string]: unknown;
            };
            error?: {
                [key: string]: unknown;
            };
            /** Format: date-time */
            createdAt?: string;
            /** Format: date-time */
            finishedOn?: string;
            /** Format: date-time */
            processedOn?: string;
        };
        AddUserResponse: {
            user?: {
                id?: components["schemas"]["id"];
                account?: {
                    id?: components["schemas"]["id"];
                };
            };
        };
        VideoUploadRequestCommon: {
            /**
             * @description Video name
             * @example What is PeerTube?
             */
            name: string;
            /**
             * @description Channel id that will contain this video
             * @example 3
             */
            channelId: number;
            privacy?: components["schemas"]["VideoPrivacySet"];
            category?: components["schemas"]["VideoCategorySet"];
            licence?: components["schemas"]["VideoLicenceSet"];
            language?: components["schemas"]["VideoLanguageSet"];
            /**
             * @description Video description
             * @example **[Want to help to translate this video?](https://weblate.framasoft.org/projects/what-is-peertube-video/)**\r\n\r\n**Take back the control of your videos! [#JoinPeertube](https://joinpeertube.org)**
             *
             */
            description?: string;
            /** @description Whether or not we wait transcoding before publish the video */
            waitTranscoding?: boolean;
            /** @description **PeerTube >= 6.2** If enabled by the admin, automatically generate a subtitle of the video */
            generateTranscription?: boolean;
            /**
             * @description A text tell the audience how to support the video creator
             * @example Please support our work on https://soutenir.framasoft.org/en/ <3
             */
            support?: string;
            /** @description Whether or not this video contains sensitive content */
            nsfw?: boolean;
            /** @description More information about the sensitive content of the video */
            nsfwSummary?: unknown;
            nsfwFlags?: components["schemas"]["NSFWFlag"];
            /**
             * @description Video tags (maximum 5 tags each between 2 and 30 characters)
             * @example [
             *       "framasoft",
             *       "peertube"
             *     ]
             */
            tags?: string[];
            /**
             * @deprecated
             * @description Deprecated in 6.2, use commentsPolicy instead
             */
            commentsEnabled?: boolean;
            commentsPolicy?: components["schemas"]["VideoCommentsPolicySet"];
            /** @description Enable or disable downloading for this video */
            downloadEnabled?: boolean;
            /**
             * Format: date-time
             * @description Date when the content was originally published
             */
            originallyPublishedAt?: string;
            scheduleUpdate?: components["schemas"]["VideoScheduledUpdate"];
            /**
             * Format: binary
             * @description Video thumbnail file
             */
            thumbnailfile?: string;
            /**
             * Format: binary
             * @description Video preview file
             */
            previewfile?: string;
            videoPasswords?: components["schemas"]["AddVideoPasswords"];
        };
        VideoUploadRequestLegacy: components["schemas"]["VideoUploadRequestCommon"] & {
            /**
             * Format: binary
             * @description Video file
             */
            videofile: string;
        };
        VideoUploadRequestResumable: components["schemas"]["VideoUploadRequestCommon"] & {
            /**
             * Format: filename
             * @description Video filename including extension
             * @example what_is_peertube.mp4
             */
            filename: string;
            /**
             * Format: binary
             * @description Video thumbnail file
             */
            thumbnailfile?: string;
            /**
             * Format: binary
             * @description Video preview file
             */
            previewfile?: string;
        };
        VideoUploadResponse: {
            video?: {
                id?: components["schemas"]["Video"]["id"];
                uuid?: components["schemas"]["Video"]["uuid"];
                shortUUID?: components["schemas"]["Video"]["shortUUID"];
            };
        };
        VideoReplaceSourceRequestResumable: {
            /**
             * Format: filename
             * @description Video filename including extension
             * @example what_is_peertube.mp4
             */
            filename?: string;
        };
        UserImportResumable: {
            /**
             * Format: filename
             * @description Archive filename including extension
             * @example user-export-6-2024-02-09T10_12_11.682Z
             */
            filename?: string;
        };
        CommentThreadResponse: {
            /** @description Total threads (included deleted ones) on this video */
            total?: number;
            /** @description Total not-deleted threads (included deleted ones) on this video */
            totalNotDeletedComments?: number;
            data?: components["schemas"]["VideoComment"][];
        };
        CommentThreadPostResponse: {
            comment?: components["schemas"]["VideoComment"];
        };
        VideoTokenResponse: {
            files?: {
                token?: string;
                /** Format: date-time */
                expires?: string;
            };
        };
        VideoListResponse: {
            /** @example 1 */
            total?: number;
            data?: components["schemas"]["Video"][];
        };
        User: {
            account?: components["schemas"]["Account"];
            /** @description Automatically start playing the upcoming video after the currently playing video */
            autoPlayNextVideo?: boolean;
            /** @description Automatically start playing the video on the playlist after the currently playing video */
            autoPlayNextVideoPlaylist?: boolean;
            /** @description Automatically start playing the video on the watch page */
            autoPlayVideo?: boolean;
            blocked?: boolean;
            blockedReason?: string;
            createdAt?: string;
            /**
             * Format: email
             * @description The user email
             */
            email?: string;
            /** @description Has the user confirmed their email address? */
            emailVerified?: boolean;
            readonly id?: components["schemas"]["id"];
            /** @description Auth plugin to use to authenticate the user */
            pluginAuth?: string;
            /** Format: date-time */
            lastLoginDate?: string;
            noInstanceConfigWarningModal?: boolean;
            noAccountSetupWarningModal?: boolean;
            noWelcomeModal?: boolean;
            nsfwPolicy?: components["schemas"]["NSFWPolicy"];
            nsfwFlagsDisplayed?: components["schemas"]["NSFWFlag"];
            nsfwFlagsHidden?: components["schemas"]["NSFWFlag"];
            nsfwFlagsWarned?: components["schemas"]["NSFWFlag"];
            nsfwFlagsBlurred?: components["schemas"]["NSFWFlag"];
            role?: {
                id?: components["schemas"]["UserRole"];
                /** @enum {string} */
                label?: "User" | "Moderator" | "Administrator";
            };
            /** @description Theme enabled by this user */
            theme?: string;
            username?: components["schemas"]["username"];
            videoChannels?: components["schemas"]["VideoChannel"][];
            /**
             * @description The user video quota in bytes
             * @example -1
             */
            videoQuota?: number;
            /**
             * @description The user daily video quota in bytes
             * @example -1
             */
            videoQuotaDaily?: number;
            /** @description Enable P2P in the player */
            p2pEnabled?: boolean;
        };
        UserWithStats: components["schemas"]["User"] & {
            /** @description Count of videos published */
            videosCount?: number;
            /** @description Count of reports/abuses of which the user is a target */
            abusesCount?: number;
            /** @description Count of reports/abuses created by the user and accepted/acted upon by the moderation team */
            abusesAcceptedCount?: number;
            /** @description Count of reports/abuses created by the user */
            abusesCreatedCount?: number;
            /** @description Count of comments published */
            videoCommentsCount?: number;
        };
        AddUser: {
            username: components["schemas"]["username"];
            password: components["schemas"]["password"];
            /**
             * Format: email
             * @description The user email
             */
            email: string;
            /**
             * @description The user video quota in bytes
             * @example -1
             */
            videoQuota?: number;
            /**
             * @description The user daily video quota in bytes
             * @example -1
             */
            videoQuotaDaily?: number;
            channelName?: components["schemas"]["usernameChannel"];
            role: components["schemas"]["UserRole"];
            adminFlags?: components["schemas"]["UserAdminFlags"];
        };
        UpdateUser: {
            /** @description The updated email of the user */
            email?: components["schemas"]["User"]["email"];
            /** @description Set the email as verified */
            emailVerified?: boolean;
            /** @description The updated video quota of the user in bytes */
            videoQuota?: number;
            /** @description The updated daily video quota of the user in bytes */
            videoQuotaDaily?: number;
            /**
             * @description The auth plugin to use to authenticate the user
             * @example peertube-plugin-auth-saml2
             */
            pluginAuth?: string | null;
            role?: components["schemas"]["UserRole"];
            adminFlags?: components["schemas"]["UserAdminFlags"];
            password?: components["schemas"]["password"];
        };
        UpdateMe: {
            password?: components["schemas"]["password"];
            currentPassword?: components["schemas"]["password"];
            /** @description new email used for login and service communications */
            email?: components["schemas"]["User"]["email"];
            /** @description new name of the user in its representations */
            displayName?: string;
            /**
             * @description new NSFW display policy
             * @enum {string}
             */
            nsfwPolicy?: "true" | "false" | "both";
            nsfwFlagsDisplayed?: components["schemas"]["NSFWFlag"];
            nsfwFlagsHidden?: components["schemas"]["NSFWFlag"];
            nsfwFlagsWarned?: components["schemas"]["NSFWFlag"];
            nsfwFlagsBlurred?: components["schemas"]["NSFWFlag"];
            /** @description whether to enable P2P in the player or not */
            p2pEnabled?: boolean;
            /** @description new preference regarding playing videos automatically */
            autoPlayVideo?: boolean;
            /** @description new preference regarding playing following videos automatically */
            autoPlayNextVideo?: boolean;
            /** @description new preference regarding playing following playlist videos automatically */
            autoPlayNextVideoPlaylist?: boolean;
            /** @description whether to keep track of watched history or not */
            videosHistoryEnabled?: boolean;
            /** @description list of languages to filter videos down to */
            videoLanguages?: string[];
            theme?: string;
            noInstanceConfigWarningModal?: boolean;
            noAccountSetupWarningModal?: boolean;
            noWelcomeModal?: boolean;
        };
        GetMeVideoRating: {
            id: components["schemas"]["id"];
            /**
             * @description Rating of the video
             * @enum {string}
             */
            rating: "like" | "dislike" | "none";
        };
        VideoRating: {
            video: components["schemas"]["Video"];
            /**
             * @description Rating of the video
             * @enum {string}
             */
            rating: "like" | "dislike" | "none";
        };
        RegisterUser: {
            /** @description immutable name of the user, used to find or mention its actor */
            username: components["schemas"]["username"];
            password: components["schemas"]["password"];
            /**
             * Format: email
             * @description email of the user, used for login or service communications
             */
            email: string;
            /** @description editable name of the user, displayed in its representations */
            displayName?: string;
            /** @description channel base information used to create the first channel of the user */
            channel?: {
                name?: components["schemas"]["usernameChannel"];
                displayName?: string;
            };
        };
        UserRegistrationRequest: components["schemas"]["RegisterUser"] & {
            /** @description reason for the user to register on the instance */
            registrationReason: string;
        };
        UserRegistrationAcceptOrReject: {
            /** @description Moderation response to send to the user */
            moderationResponse: string;
            /** @description Set it to true if you don't want PeerTube to send an email to the user */
            preventEmailDelivery?: boolean;
        };
        UserRegistration: {
            id?: components["schemas"]["id"];
            state?: {
                /**
                 * @description The registration state (Pending = `1`, Rejected = `2`, Accepted = `3`)
                 * @enum {integer}
                 */
                id?: 1 | 2 | 3;
                label?: string;
            };
            registrationReason?: string;
            moderationResponse?: string | null;
            username?: string;
            /** Format: email */
            email?: string;
            emailVerified?: boolean;
            accountDisplayName?: string;
            channelHandle?: string;
            channelDisplayName?: string;
            /** Format: date-time */
            createdAt?: string;
            /** Format: date-time */
            updatedAt?: string;
            /** @description If the registration has been accepted, this is a partial user object created by the registration */
            user?: {
                id?: components["schemas"]["id"];
            } | null;
        };
        OAuthClient: {
            /** @example v1ikx5hnfop4mdpnci8nsqh93c45rldf */
            client_id?: string;
            /** @example AjWiOapPltI6EnsWQwlFarRtLh4u8tDt */
            client_secret?: string;
        };
        "OAuthToken-password": WithRequired<components["schemas"]["OAuthClient"], "client_id" | "client_secret"> & {
            /**
             * @default password
             * @enum {string}
             */
            grant_type: "password" | "refresh_token";
            username: components["schemas"]["User"]["username"];
            password: components["schemas"]["password"];
        } & {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            grant_type: "password";
        };
        "OAuthToken-refresh_token": WithRequired<components["schemas"]["OAuthClient"], "client_id" | "client_secret"> & {
            /**
             * @default password
             * @enum {string}
             */
            grant_type: "password" | "refresh_token";
            /** @example 2e0d675df9fc96d2e4ec8a3ebbbf45eca9137bb7 */
            refresh_token: string;
        } & {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            grant_type: "refresh_token";
        };
        VideoChannel: components["schemas"]["Actor"] & {
            /**
             * @description editable name of the channel, displayed in its representations
             * @example Videos of Framasoft
             */
            displayName?: string;
            /** @example Videos made with <3 by Framasoft */
            description?: string | null;
            /**
             * @description text shown by default on all videos of this channel, to tell the audience how to support it
             * @example Please support our work on https://soutenir.framasoft.org/en/ <3
             */
            support?: string | null;
            readonly isLocal?: boolean;
            /** Format: date-time */
            readonly updatedAt?: string;
            banners?: components["schemas"]["ActorImage"][];
            ownerAccount?: components["schemas"]["Account"];
        };
        VideoChannelEdit: {
            /** @description Channel display name */
            displayName?: unknown;
            /** @description Channel description */
            description?: unknown;
            /** @description How to support/fund the channel */
            support?: unknown;
        };
        VideoChannelCreate: WithRequired<components["schemas"]["VideoChannelEdit"], "displayName"> & {
            /** @description username of the channel to create */
            name: components["schemas"]["usernameChannel"];
        };
        VideoChannelUpdate: components["schemas"]["VideoChannelEdit"] & {
            /** @description Update the support field for all videos of this channel */
            bulkVideosSupportUpdate?: boolean;
        };
        VideoChannelList: {
            /** @example 1 */
            total?: number;
            data?: (components["schemas"]["VideoChannel"] & components["schemas"]["Actor"])[];
        };
        ImportVideosInChannelCreate: {
            /** @example https://youtube.com/c/UC_myfancychannel */
            externalChannelUrl: string;
            /** @description If part of a channel sync process, specify its id to assign video imports to this channel synchronization */
            videoChannelSyncId?: number;
        };
        VideoChannelSync: {
            id?: components["schemas"]["id"];
            state?: {
                /** @example 2 */
                id?: number;
                /** @example PROCESSING */
                label?: string;
            };
            /** @example https://youtube.com/c/UC_myfancychannel */
            externalChannelUrl?: string;
            /** Format: date-time */
            createdAt?: string;
            /** Format: date-time */
            lastSyncAt?: string | null;
            channel?: components["schemas"]["VideoChannel"];
        };
        VideoChannelSyncList: {
            /** @example 1 */
            total?: number;
            data?: components["schemas"]["VideoChannelSync"][];
        };
        VideoChannelSyncCreate: {
            /** @example https://youtube.com/c/UC_myfancychannel */
            externalChannelUrl?: string;
            videoChannelId?: components["schemas"]["id"];
        };
        MRSSPeerLink: {
            href?: string;
            /** @enum {string} */
            type?: "application/x-bittorrent";
        };
        MRSSGroupContent: {
            /** Format: url */
            url?: string;
            fileSize?: number;
            type?: string;
            framerate?: number;
            duration?: number;
            height?: number;
            lang?: string;
        };
        VideoCommentsForXML: {
            /** Format: url */
            link?: string;
            guid?: string;
            /** Format: date-time */
            pubDate?: string;
            "content:encoded"?: string;
            "dc:creator"?: string;
        }[];
        VideosForXML: {
            /**
             * Format: url
             * @description video watch page URL
             */
            link?: string;
            /** @description video canonical URL */
            guid?: string;
            /**
             * Format: date-time
             * @description video publication date
             */
            pubDate?: string;
            /** @description video description */
            description?: string;
            /** @description video description */
            "content:encoded"?: string;
            /** @description publisher user name */
            "dc:creator"?: string;
            /** @description video category (MRSS) */
            "media:category"?: number;
            /** @description see [media:community](https://www.rssboard.org/media-rss#media-community) (MRSS) */
            "media:community"?: {
                "media:statistics"?: {
                    views?: number;
                };
            };
            "media:embed"?: {
                /**
                 * Format: url
                 * @description video embed path, relative to the canonical URL domain (MRSS)
                 */
                url?: string;
            };
            "media:player"?: {
                /**
                 * Format: url
                 * @description video watch path, relative to the canonical URL domain (MRSS)
                 */
                url?: string;
            };
            "media:thumbnail"?: {
                /** Format: url */
                url?: string;
                height?: number;
                width?: number;
            };
            /** @description see [media:title](https://www.rssboard.org/media-rss#media-title) (MRSS). We only use `plain` titles. */
            "media:title"?: string;
            "media:description"?: string;
            /**
             * @description see [media:rating](https://www.rssboard.org/media-rss#media-rating) (MRSS)
             * @enum {string}
             */
            "media:rating"?: "nonadult" | "adult";
            /** @description main streamable file for the video */
            enclosure?: {
                /** Format: url */
                url?: string;
                /** @enum {string} */
                type?: "application/x-bittorrent";
                length?: number;
            };
            /** @description list of streamable files for the video. see [media:peerLink](https://www.rssboard.org/media-rss#media-peerlink) and [media:content](https://www.rssboard.org/media-rss#media-content) or  (MRSS) */
            "media:group"?: (components["schemas"]["MRSSPeerLink"] | components["schemas"]["MRSSGroupContent"])[];
        }[];
        /** @description Notification type. One of the following values, or a sum of multiple values:
         *     - `0` NONE
         *     - `1` WEB
         *     - `2` EMAIL
         *      */
        NotificationSettingValue: number;
        /**
         * @description Notification type. One of the following values:
         *
         *       - `1` NEW_VIDEO_FROM_SUBSCRIPTION
         *
         *       - `2` NEW_COMMENT_ON_MY_VIDEO
         *
         *       - `3` NEW_ABUSE_FOR_MODERATORS
         *
         *       - `4` BLACKLIST_ON_MY_VIDEO
         *
         *       - `5` UNBLACKLIST_ON_MY_VIDEO
         *
         *       - `6` MY_VIDEO_PUBLISHED
         *
         *       - `7` MY_VIDEO_IMPORT_SUCCESS
         *
         *       - `8` MY_VIDEO_IMPORT_ERROR
         *
         *       - `9` NEW_USER_REGISTRATION
         *
         *       - `10` NEW_FOLLOW
         *
         *       - `11` COMMENT_MENTION
         *
         *       - `12` VIDEO_AUTO_BLACKLIST_FOR_MODERATORS
         *
         *       - `13` NEW_INSTANCE_FOLLOWER
         *
         *       - `14` AUTO_INSTANCE_FOLLOWING
         *
         *       - `15` ABUSE_STATE_CHANGE
         *
         *       - `16` ABUSE_NEW_MESSAGE
         *
         *       - `17` NEW_PLUGIN_VERSION
         *
         *       - `18` NEW_PEERTUBE_VERSION
         *
         *       - `19` MY_VIDEO_STUDIO_EDITION_FINISHED
         *
         *       - `20` NEW_USER_REGISTRATION_REQUEST
         *
         *       - `21` NEW_LIVE_FROM_SUBSCRIPTION
         *
         *       - `22` MY_VIDEO_TRANSCRIPTION_GENERATED
         *
         * @enum {integer}
         */
        NotificationType: 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 | 16 | 17 | 18 | 19 | 20 | 21 | 22;
        Notification: {
            id?: components["schemas"]["id"];
            type?: components["schemas"]["NotificationType"];
            read?: boolean;
            video?: (components["schemas"]["VideoInfo"] & {
                channel?: components["schemas"]["ActorInfo"];
            }) | null;
            videoImport?: {
                id?: components["schemas"]["id"];
                video?: components["schemas"]["VideoInfo"];
                torrentName?: string | null;
                magnetUri?: components["schemas"]["VideoImport"]["magnetUri"];
                /** Format: uri */
                targetUri?: string | null;
            } | null;
            comment?: {
                id?: components["schemas"]["id"];
                threadId?: number;
                video?: components["schemas"]["VideoInfo"];
                account?: components["schemas"]["ActorInfo"];
                heldForReview?: boolean;
            } | null;
            videoAbuse?: {
                id?: components["schemas"]["id"];
                video?: components["schemas"]["VideoInfo"];
            } | null;
            videoBlacklist?: {
                id?: components["schemas"]["id"];
                video?: components["schemas"]["VideoInfo"];
            } | null;
            account?: components["schemas"]["ActorInfo"] | null;
            actorFollow?: {
                id?: components["schemas"]["id"];
                follower?: components["schemas"]["ActorInfo"];
                /** @enum {string} */
                state?: "pending" | "accepted";
                following?: {
                    /** @enum {string} */
                    type?: "account" | "channel" | "instance";
                    name?: string;
                    displayName?: string;
                    /** Format: hostname */
                    host?: string;
                };
            } | null;
            /** Format: date-time */
            createdAt?: string;
            /** Format: date-time */
            updatedAt?: string;
        };
        NotificationListResponse: {
            /** @example 1 */
            total?: number;
            data?: components["schemas"]["Notification"][];
        };
        Plugin: {
            /** @example peertube-plugin-auth-ldap */
            name?: string;
            /**
             * @description - `1`: PLUGIN
             *     - `2`: THEME
             *
             * @enum {integer}
             */
            type?: 1 | 2;
            /** @example 0.0.3 */
            latestVersion?: string;
            /** @example 0.0.1 */
            version?: string;
            enabled?: boolean;
            uninstalled?: boolean;
            /** @example 2.2.0 */
            peertubeEngine?: string;
            description?: string;
            /**
             * Format: url
             * @example https://framagit.org/framasoft/peertube/official-plugins/tree/master/peertube-plugin-auth-ldap
             */
            homepage?: string;
            settings?: {
                [key: string]: unknown;
            };
            /** Format: date-time */
            createdAt?: string;
            /** Format: date-time */
            updatedAt?: string;
        };
        PluginResponse: {
            /** @example 1 */
            total?: number;
            data?: components["schemas"]["Plugin"][];
        };
        LiveVideoUpdate: {
            saveReplay?: boolean;
            replaySettings?: components["schemas"]["LiveVideoReplaySettings"];
            /** @description User can stream multiple times in a permanent live */
            permanentLive?: boolean;
            /** @description User can select live latency mode if enabled by the instance */
            latencyMode?: components["schemas"]["LiveVideoLatencyMode"];
        };
        LiveVideoResponse: {
            /** @description Included in the response if an appropriate token is provided */
            rtmpUrl?: string;
            /** @description Included in the response if an appropriate token is provided */
            rtmpsUrl?: string;
            /** @description RTMP stream key to use to stream into this live video. Included in the response if an appropriate token is provided */
            streamKey?: string;
            saveReplay?: boolean;
            replaySettings?: components["schemas"]["LiveVideoReplaySettings"];
            /** @description User can stream multiple times in a permanent live */
            permanentLive?: boolean;
            /** @description User can select live latency mode if enabled by the instance */
            latencyMode?: components["schemas"]["LiveVideoLatencyMode"];
        };
        RequestTwoFactorResponse: {
            otpRequest?: {
                /** @description The token to send to confirm this request */
                requestToken?: string;
                /** @description The OTP secret */
                secret?: string;
                /** @description The OTP URI */
                uri?: string;
            };
        };
        VideoStudioCreateTask: ({
            /** @enum {string} */
            name?: "cut";
            options?: {
                start?: number;
                end?: number;
            };
        } | {
            /** @enum {string} */
            name?: "add-intro";
            options?: {
                /** Format: binary */
                file?: string;
            };
        } | {
            /** @enum {string} */
            name?: "add-outro";
            options?: {
                /** Format: binary */
                file?: string;
            };
        } | {
            /** @enum {string} */
            name?: "add-watermark";
            options?: {
                /** Format: binary */
                file?: string;
            };
        })[];
        LiveVideoSessionResponse: {
            id?: number;
            /**
             * Format: date-time
             * @description Start date of the live session
             */
            startDate?: string;
            /**
             * Format: date-time
             * @description End date of the live session
             */
            endDate?: string | null;
            /**
             * @description Error type if an error occurred during the live session:
             *       - `1`: Bad socket health (transcoding is too slow)
             *       - `2`: Max duration exceeded
             *       - `3`: Quota exceeded
             *       - `4`: Quota FFmpeg error
             *       - `5`: Video has been blacklisted during the live
             *
             * @enum {integer|null}
             */
            error?: 1 | 2 | 3 | 4 | 5 | null;
            /** @description Video replay information */
            replayVideo?: {
                id?: number;
                uuid?: components["schemas"]["UUIDv4"];
                shortUUID?: components["schemas"]["shortUUID"];
            };
        };
        PlaybackMetricCreate: {
            /** @enum {string} */
            playerMode: "p2p-media-loader" | "web-video";
            /** @description Current player video resolution */
            resolution?: number;
            /** @description Current player video fps */
            fps?: number;
            p2pEnabled: boolean;
            /** @description P2P peers connected (doesn't include WebSeed peers) */
            p2pPeers?: number;
            /** @description How many resolution changes occurred since the last metric creation */
            resolutionChanges: number;
            /** @description How many times buffer has been stalled since the last metric creation */
            bufferStalled?: number;
            /** @description How many errors occurred since the last metric creation */
            errors: number;
            /** @description How many bytes were downloaded with P2P since the last metric creation */
            downloadedBytesP2P: number;
            /** @description How many bytes were downloaded with HTTP since the last metric creation */
            downloadedBytesHTTP: number;
            /** @description How many bytes were uploaded with P2P since the last metric creation */
            uploadedBytesP2P: number;
            videoId: components["schemas"]["id"] | components["schemas"]["UUIDv4"] | components["schemas"]["shortUUID"];
        };
        RunnerRegistrationToken: {
            id?: number;
            registrationToken?: string;
            /** Format: date-time */
            createdAt?: string;
            /** Format: date-time */
            updatedAt?: string;
            registeredRunnersCount?: number;
        };
        Runner: {
            id?: number;
            name?: string;
            description?: string;
            ip?: string;
            /** Format: date-time */
            updatedAt?: string;
            /** Format: date-time */
            createdAt?: string;
            /** Format: date-time */
            lastContact?: string;
        };
        /** @enum {string} */
        RunnerJobType: "vod-web-video-transcoding" | "vod-hls-transcoding" | "vod-audio-merge-transcoding" | "live-rtmp-hls-transcoding";
        /**
         * @description The runner job state:
         *       - `1` Pending
         *       - `2` Processing
         *       - `3` Completed
         *       - `4` Errored
         *       - `5` Waiting for a parent job
         *       - `6` Cancelled
         *       - `7` Parent had an error
         *       - `8` Parent has been cancelled
         *
         * @enum {integer}
         */
        RunnerJobState: 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8;
        RunnerJobStateConstant: {
            id?: components["schemas"]["RunnerJobState"];
            /** @example Processing */
            label?: string;
        };
        RunnerJobPayload: {
            input?: {
                videoFileUrl?: string;
            };
            output?: {
                resolution?: number;
                fps?: number;
            };
        } | {
            input?: {
                videoFileUrl?: string;
            };
            output?: {
                resolution?: number;
                fps?: number;
            };
        } | {
            input?: {
                audioFileUrl?: string;
                previewFileUrl?: string;
            };
            output?: {
                resolution?: number;
                fps?: number;
            };
        };
        RunnerJob: {
            uuid?: components["schemas"]["UUIDv4"];
            type?: components["schemas"]["RunnerJobType"];
            state?: components["schemas"]["RunnerJobStateConstant"];
            payload?: components["schemas"]["RunnerJobPayload"];
            /** @description Number of times a remote runner failed to process this job. After too many failures, the job in "error" state */
            failures?: number;
            /** @description Error message if the job is errored */
            error?: string | null;
            /** @description Percentage progress */
            progress?: number;
            /** @description Job priority (less has more priority) */
            priority?: number;
            /** Format: date-time */
            updatedAt?: string;
            /** Format: date-time */
            createdAt?: string;
            /** Format: date-time */
            startedAt?: string;
            /** Format: date-time */
            finishedAt?: string;
            /** @description If job has a parent job */
            parent?: {
                type?: components["schemas"]["RunnerJobType"];
                state?: components["schemas"]["RunnerJobStateConstant"];
                uuid?: components["schemas"]["UUIDv4"];
            } | null;
            /** @description If job is associated to a runner */
            runner?: {
                id?: number;
                name?: string;
                description?: string;
            } | null;
        };
        RunnerJobAdmin: components["schemas"]["RunnerJob"] & {
            privatePayload?: Record<string, never>;
        };
        WatchedWordsLists: {
            id?: components["schemas"]["id"];
            listName?: string;
            words?: string[];
            /**
             * Format: date-time
             * @example 2021-05-04T08:01:01.502Z
             */
            updatedAt?: string;
            /**
             * Format: date-time
             * @example 2021-05-04T08:01:01.502Z
             */
            createdAt?: string;
        };
        VideoPassword: {
            id?: components["schemas"]["id"];
            password?: string;
            videoId?: components["schemas"]["id"];
        };
        VideoPasswordList: {
            /** @example 1 */
            total?: number;
            data?: components["schemas"]["VideoPassword"][];
        };
        AddVideoPasswords: components["schemas"]["VideoPassword"]["password"][];
        /**
         * @description The file storage type:
         *       - `0` File system
         *       - `1` Object storage
         *
         * @enum {integer}
         */
        FileStorage: 0 | 1;
    };
    responses: never;
    parameters: {
        /** @description Offset used to paginate results */
        start: number;
        /** @description Number of items to return */
        count: number;
        /** @description Sort column */
        sort: string;
        /** @description Plain text search, applied to various parts of the model depending on endpoint */
        search: string;
        /** @description If the administrator enabled search index support, you can override the default search target.
         *
         *     **Warning**: If you choose to make an index search, PeerTube will get results from a third party service. It means the instance may not yet know the objects you fetched. If you want to load video/channel information:
         *       * If the current user has the ability to make a remote URI search (this information is available in the config endpoint),
         *       then reuse the search API to make a search using the object URI so PeerTube instance fetches the remote object and fill its database.
         *       After that, you can use the classic REST API endpoints to fetch the complete object or interact with it
         *       * If the current user doesn't have the ability to make a remote URI search, then redirect the user on the origin instance or fetch
         *       the data from the origin instance API
         *      */
        searchTarget: "local" | "search-index";
        mySubscriptionSort: "-id" | "-createdAt" | "-channelUpdatedAt";
        videosSort: "name" | "-duration" | "-createdAt" | "-publishedAt" | "-views" | "-likes" | "-comments" | "-trending" | "-hot" | "-best";
        /** @description Sort videos by criteria (prefixing with `-` means `DESC` order):
         *      */
        videosSearchSort: "name" | "-duration" | "-createdAt" | "-publishedAt" | "-views" | "-likes" | "-match";
        /** @description Sort comments by criteria */
        commentsSort: "-createdAt" | "-totalReplies";
        /** @description Sort blocklists by criteria */
        blacklistsSort: "-id" | "name" | "-duration" | "-views" | "-likes" | "-dislikes" | "-uuid" | "-createdAt";
        /** @description Plain text search that will match with user usernames or emails */
        usersSearch: string;
        /** @description Filter results down to (un)banned users */
        usersBlocked: boolean;
        /** @description Sort users by criteria */
        usersSort: "-id" | "-username" | "-createdAt";
        /** @description Sort abuses by criteria */
        abusesSort: "-id" | "-createdAt" | "-state";
        /** @description Sort abuses by criteria */
        videoRedundanciesSort: "name";
        /** @description Sort followers by criteria */
        followersSort: "createdAt";
        /** @description Sort registration tokens by criteria */
        registrationTokenSort: "createdAt";
        /** @description Sort runners by criteria */
        runnerSort: "createdAt";
        /** @description Sort runner jobs by criteria */
        runnerJobSort: "updatedAt" | "createdAt" | "priority" | "state" | "progress";
        /** @description The username or handle of the account */
        name: string;
        /** @description Entity id */
        id: components["schemas"]["id"];
        /** @description User id */
        userId: components["schemas"]["id"];
        /** @description Registration ID */
        registrationId: components["schemas"]["id"];
        /** @description The object id, uuid or short uuid */
        idOrUUID: components["schemas"]["id"] | components["schemas"]["UUIDv4"] | components["schemas"]["shortUUID"];
        /** @description Playlist id */
        playlistId: components["schemas"]["VideoPlaylist"]["id"];
        /** @description Playlist element id */
        playlistElementId: components["schemas"]["id"];
        /** @description Abuse id */
        abuseId: components["schemas"]["Abuse"]["id"];
        /** @description Abuse message id */
        abuseMessageId: components["schemas"]["AbuseMessage"]["id"];
        /** @description The caption language */
        captionLanguage: components["schemas"]["VideoLanguageSet"];
        /** @description The video channel handle */
        channelHandle: string;
        /** @description Channel Sync id */
        channelSyncId: components["schemas"]["Abuse"]["id"];
        /** @description The subscription handle */
        subscriptionHandle: string;
        /** @description The thread id (root comment id) */
        threadId: number;
        /** @description The comment id */
        commentId: components["schemas"]["VideoComment"]["id"];
        /** @description whether or not the video is a live */
        isLive: boolean;
        /** @description category id of the video (see [/videos/categories](#operation/getCategories)) */
        categoryOneOf: components["schemas"]["VideoCategorySet"] | components["schemas"]["VideoCategorySet"][];
        /** @description tag(s) of the video */
        tagsOneOf: string | string[];
        /** @description tag(s) of the video, where all should be present in the video */
        tagsAllOf: string | string[];
        /** @description language id of the video (see [/videos/languages](#operation/getLanguages)). Use `_unknown` to filter on videos that don't have a video language */
        languageOneOf: components["schemas"]["VideoLanguageSet"] | components["schemas"]["VideoLanguageSet"][];
        /** @description **PeerTube >= 6.2** **Admins and moderators only** filter on videos that contain one of these automatic tags */
        autoTagOneOfVideo: string | string[];
        /** @description **PeerTube >= 7.2** Filter on videos that are published by a channel with one of these names */
        channelNameOneOf: string | string[];
        /** @description **PeerTube >= 6.2** filter on comments that contain one of these automatic tags */
        autoTagOneOfComment: string | string[];
        /** @description only display comments that are held for review */
        isHeldForReview: boolean;
        /** @description licence id of the video (see [/videos/licences](#operation/getLicences)) */
        licenceOneOf: components["schemas"]["VideoLicenceSet"] | components["schemas"]["VideoLicenceSet"][];
        /** @description if you don't need the `total` in the response */
        skipCount: "true" | "false";
        /** @description whether to include nsfw videos, if any */
        nsfw: "true" | "false";
        nsfwFlagsIncluded: components["schemas"]["NSFWFlag"];
        nsfwFlagsExcluded: components["schemas"]["NSFWFlag"];
        /** @description **PeerTube >= 4.0** Display only local or remote objects */
        isLocal: boolean;
        /** @description **PeerTube >= 4.0** Display only videos that have HLS files */
        hasHLSFiles: boolean;
        /** @description **PeerTube >= 6.0** Display only videos that have Web Video files */
        hasWebVideoFiles: boolean;
        /** @description **PeerTube >= 4.0** Display only videos in this specific privacy/privacies */
        privacyOneOf: components["schemas"]["VideoPrivacySet"];
        /** @description Whether or not to exclude videos that are in the user's video history */
        excludeAlreadyWatched: boolean;
        /** @description Find elements with specific UUIDs */
        uuids: unknown;
        /** @description Find elements owned by this host */
        host: string;
        /** @description Find elements with these handles */
        handles: unknown;
        /** @description **Only administrators and moderators can use this parameter**
         *
         *     Include additional videos in results (can be combined using bitwise or operator)
         *     - `0` NONE
         *     - `1` NOT_PUBLISHED_STATE
         *     - `2` BLACKLISTED
         *     - `4` BLOCKED_OWNER
         *     - `8` FILES
         *     - `16` CAPTIONS
         *     - `32` VIDEO SOURCE
         *      */
        include: 0 | 1 | 2 | 4 | 8 | 16 | 32;
        /** @description list of uris to check if each is part of the user subscriptions */
        subscriptionsUris: string[];
        /** @description name of the plugin/theme on npmjs.com or in its package.json */
        npmName: string;
        /** @description job type */
        jobType: "activitypub-follow" | "activitypub-http-broadcast" | "activitypub-http-fetcher" | "activitypub-http-unicast" | "email" | "video-transcoding" | "video-file-import" | "video-import" | "videos-views-stats" | "activitypub-refresher" | "video-redundancy" | "video-live-ending" | "video-channel-import";
        followState: "pending" | "accepted";
        actorType: "Person" | "Application" | "Group" | "Service" | "Organization";
        /** @description Filename */
        staticFilename: string;
        /** @description Video file token [generated](#operation/requestVideoToken) by PeerTube so you don't need to provide an OAuth token in the request header. */
        videoFileToken: string;
        /** @description Ask the server to reinject videoFileToken in URLs in m3u8 playlist */
        reinjectVideoFileToken: boolean;
        videoPlaylistType: components["schemas"]["VideoPlaylistTypeSet"];
        registrationTokenId: number;
        runnerId: number;
        jobUUID: components["schemas"]["UUIDv4"];
        /** @description The video password id */
        videoPasswordId: components["schemas"]["id"];
        /** @description Display only objects of local or remote videos */
        onLocalVideo: boolean;
        /** @description Limit results on this specific video channel */
        videoChannelId: number;
        /** @description Limit results on this specific video */
        videoId: number;
        /** @description Filter comments by searching on the video */
        searchVideoForComments: string;
        /** @description Filter comments by searching on the account */
        searchAccountForComments: string;
        /** @description Required on password protected video */
        videoPasswordHeader: string;
        /** @description Number of bytes that will be uploaded in subsequent requests. Set this value to the size of the file you are uploading. */
        resumableUploadInitContentLengthHeader: number;
        /** @description MIME type of the file that you are uploading. Depending on your instance settings, acceptable values might vary. */
        resumableUploadInitContentTypeHeader: string;
        /** @description Specifies the bytes in the file that the request is uploading.
         *
         *     For example, a value of `bytes 0-262143/1000000` shows that the request is sending the first
         *     262144 bytes (256 x 1024) in a 2,469,036 byte file.
         *      */
        resumableUploadChunkContentRangeHeader: string;
        /** @description Size of the chunk that the request is sending.
         *
         *     Remember that larger chunks are more efficient. PeerTube's web client uses chunks varying from
         *     1048576 bytes (~1MB) and increases or reduces size depending on connection health.
         *      */
        resumableUploadChunkContentLengthHeader: number;
        /** @description Created session id to proceed with. If you didn't send chunks in the last hour, it is
         *     not valid anymore and you need to initialize a new upload.
         *      */
        resumableUploadId: string;
    };
    requestBodies: never;
    headers: never;
    pathItems: never;
}
export type $defs = Record<string, never>;
export interface operations {
    getSyndicatedComments: {
        parameters: {
            query?: {
                /** @description limit listing comments to a specific video */
                videoId?: string;
                /** @description limit listing comments to videos of a specific account */
                accountId?: string;
                /** @description limit listing comments to videos of a specific account */
                accountName?: string;
                /** @description limit listing comments to videos of a specific video channel */
                videoChannelId?: string;
                /** @description limit listing comments to videos of a specific video channel */
                videoChannelName?: string;
            };
            header?: never;
            path: {
                /** @description format expected (we focus on making `rss` the most featureful ; it serves [Media RSS](https://www.rssboard.org/media-rss)) */
                format: "xml" | "rss" | "rss2" | "atom" | "atom1" | "json" | "json1";
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description successful operation */
            200: {
                headers: {
                    "Cache-Control"?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/xml": components["schemas"]["VideoCommentsForXML"];
                    "application/rss+xml": components["schemas"]["VideoCommentsForXML"];
                    "text/xml": components["schemas"]["VideoCommentsForXML"];
                    "application/atom+xml": components["schemas"]["VideoCommentsForXML"];
                    "application/json": Record<string, never>;
                };
            };
            /** @description Arises when:
             *       - videoId filter is mixed with a channel filter
             *      */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description video, video channel or account not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description accept header unsupported */
            406: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getSyndicatedVideos: {
        parameters: {
            query?: {
                /** @description limit listing to a specific account */
                accountId?: string;
                /** @description limit listing to a specific account */
                accountName?: string;
                /** @description limit listing to a specific video channel */
                videoChannelId?: string;
                /** @description limit listing to a specific video channel */
                videoChannelName?: string;
                /** @description Sort column */
                sort?: components["parameters"]["sort"];
                /** @description whether to include nsfw videos, if any */
                nsfw?: components["parameters"]["nsfw"];
                /** @description **PeerTube >= 4.0** Display only local or remote objects */
                isLocal?: components["parameters"]["isLocal"];
                /** @description **Only administrators and moderators can use this parameter**
                 *
                 *     Include additional videos in results (can be combined using bitwise or operator)
                 *     - `0` NONE
                 *     - `1` NOT_PUBLISHED_STATE
                 *     - `2` BLACKLISTED
                 *     - `4` BLOCKED_OWNER
                 *     - `8` FILES
                 *     - `16` CAPTIONS
                 *     - `32` VIDEO SOURCE
                 *      */
                include?: components["parameters"]["include"];
                /** @description **PeerTube >= 4.0** Display only videos in this specific privacy/privacies */
                privacyOneOf?: components["parameters"]["privacyOneOf"];
                /** @description **PeerTube >= 4.0** Display only videos that have HLS files */
                hasHLSFiles?: components["parameters"]["hasHLSFiles"];
                /** @description **PeerTube >= 6.0** Display only videos that have Web Video files */
                hasWebVideoFiles?: components["parameters"]["hasWebVideoFiles"];
            };
            header?: never;
            path: {
                /** @description format expected (we focus on making `rss` the most featureful ; it serves [Media RSS](https://www.rssboard.org/media-rss)) */
                format: "xml" | "rss" | "rss2" | "atom" | "atom1" | "json" | "json1";
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description successful operation */
            200: {
                headers: {
                    "Cache-Control"?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/xml": components["schemas"]["VideosForXML"];
                    "application/rss+xml": components["schemas"]["VideosForXML"];
                    "text/xml": components["schemas"]["VideosForXML"];
                    "application/atom+xml": components["schemas"]["VideosForXML"];
                    "application/json": Record<string, never>;
                };
            };
            /** @description video channel or account not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description accept header unsupported */
            406: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getSyndicatedSubscriptionVideos: {
        parameters: {
            query: {
                /** @description limit listing to a specific account */
                accountId: string;
                /** @description private token allowing access */
                token: string;
                /** @description Sort column */
                sort?: components["parameters"]["sort"];
                /** @description whether to include nsfw videos, if any */
                nsfw?: components["parameters"]["nsfw"];
                /** @description **PeerTube >= 4.0** Display only local or remote objects */
                isLocal?: components["parameters"]["isLocal"];
                /** @description **Only administrators and moderators can use this parameter**
                 *
                 *     Include additional videos in results (can be combined using bitwise or operator)
                 *     - `0` NONE
                 *     - `1` NOT_PUBLISHED_STATE
                 *     - `2` BLACKLISTED
                 *     - `4` BLOCKED_OWNER
                 *     - `8` FILES
                 *     - `16` CAPTIONS
                 *     - `32` VIDEO SOURCE
                 *      */
                include?: components["parameters"]["include"];
                /** @description **PeerTube >= 4.0** Display only videos in this specific privacy/privacies */
                privacyOneOf?: components["parameters"]["privacyOneOf"];
                /** @description **PeerTube >= 4.0** Display only videos that have HLS files */
                hasHLSFiles?: components["parameters"]["hasHLSFiles"];
                /** @description **PeerTube >= 6.0** Display only videos that have Web Video files */
                hasWebVideoFiles?: components["parameters"]["hasWebVideoFiles"];
            };
            header?: never;
            path: {
                /** @description format expected (we focus on making `rss` the most featureful ; it serves [Media RSS](https://www.rssboard.org/media-rss)) */
                format: "xml" | "rss" | "rss2" | "atom" | "atom1" | "json" | "json1";
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description successful operation */
            200: {
                headers: {
                    "Cache-Control"?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/xml": components["schemas"]["VideosForXML"];
                    "application/rss+xml": components["schemas"]["VideosForXML"];
                    "text/xml": components["schemas"]["VideosForXML"];
                    "application/atom+xml": components["schemas"]["VideosForXML"];
                    "application/json": Record<string, never>;
                };
            };
            /** @description accept header unsupported */
            406: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getVideosPodcastFeed: {
        parameters: {
            query: {
                /** @description Limit listing to a specific video channel */
                videoChannelId: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description successful operation */
            200: {
                headers: {
                    "Cache-Control"?: string;
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description video channel not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getAccount: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The username or handle of the account */
                name: components["parameters"]["name"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Account"];
                };
            };
            /** @description account not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getAccountVideos: {
        parameters: {
            query?: {
                /** @description Offset used to paginate results */
                start?: components["parameters"]["start"];
                /** @description Number of items to return */
                count?: components["parameters"]["count"];
                /** @description if you don't need the `total` in the response */
                skipCount?: components["parameters"]["skipCount"];
                sort?: components["parameters"]["videosSort"];
                /** @description whether to include nsfw videos, if any */
                nsfw?: components["parameters"]["nsfw"];
                nsfwFlagsIncluded?: components["parameters"]["nsfwFlagsIncluded"];
                nsfwFlagsExcluded?: components["parameters"]["nsfwFlagsExcluded"];
                /** @description whether or not the video is a live */
                isLive?: components["parameters"]["isLive"];
                /** @description category id of the video (see [/videos/categories](#operation/getCategories)) */
                categoryOneOf?: components["parameters"]["categoryOneOf"];
                /** @description licence id of the video (see [/videos/licences](#operation/getLicences)) */
                licenceOneOf?: components["parameters"]["licenceOneOf"];
                /** @description language id of the video (see [/videos/languages](#operation/getLanguages)). Use `_unknown` to filter on videos that don't have a video language */
                languageOneOf?: components["parameters"]["languageOneOf"];
                /** @description tag(s) of the video */
                tagsOneOf?: components["parameters"]["tagsOneOf"];
                /** @description tag(s) of the video, where all should be present in the video */
                tagsAllOf?: components["parameters"]["tagsAllOf"];
                /** @description **PeerTube >= 4.0** Display only local or remote objects */
                isLocal?: components["parameters"]["isLocal"];
                /** @description **Only administrators and moderators can use this parameter**
                 *
                 *     Include additional videos in results (can be combined using bitwise or operator)
                 *     - `0` NONE
                 *     - `1` NOT_PUBLISHED_STATE
                 *     - `2` BLACKLISTED
                 *     - `4` BLOCKED_OWNER
                 *     - `8` FILES
                 *     - `16` CAPTIONS
                 *     - `32` VIDEO SOURCE
                 *      */
                include?: components["parameters"]["include"];
                /** @description **PeerTube >= 4.0** Display only videos that have HLS files */
                hasHLSFiles?: components["parameters"]["hasHLSFiles"];
                /** @description **PeerTube >= 6.0** Display only videos that have Web Video files */
                hasWebVideoFiles?: components["parameters"]["hasWebVideoFiles"];
                /** @description Find elements owned by this host */
                host?: components["parameters"]["host"];
                /** @description **PeerTube >= 6.2** **Admins and moderators only** filter on videos that contain one of these automatic tags */
                autoTagOneOf?: components["parameters"]["autoTagOneOfVideo"];
                /** @description **PeerTube >= 4.0** Display only videos in this specific privacy/privacies */
                privacyOneOf?: components["parameters"]["privacyOneOf"];
                /** @description Whether or not to exclude videos that are in the user's video history */
                excludeAlreadyWatched?: components["parameters"]["excludeAlreadyWatched"];
                /** @description Plain text search, applied to various parts of the model depending on endpoint */
                search?: components["parameters"]["search"];
            };
            header?: never;
            path: {
                /** @description The username or handle of the account */
                name: components["parameters"]["name"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["VideoListResponse"];
                };
            };
        };
    };
    getAccountFollowers: {
        parameters: {
            query?: {
                /** @description Offset used to paginate results */
                start?: components["parameters"]["start"];
                /** @description Number of items to return */
                count?: components["parameters"]["count"];
                /** @description Sort followers by criteria */
                sort?: components["parameters"]["followersSort"];
                /** @description Plain text search, applied to various parts of the model depending on endpoint */
                search?: components["parameters"]["search"];
            };
            header?: never;
            path: {
                /** @description The username or handle of the account */
                name: components["parameters"]["name"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @example 1 */
                        total?: number;
                        data?: components["schemas"]["Follow"][];
                    };
                };
            };
        };
    };
    getAccounts: {
        parameters: {
            query?: {
                /** @description Offset used to paginate results */
                start?: components["parameters"]["start"];
                /** @description Number of items to return */
                count?: components["parameters"]["count"];
                /** @description Sort column */
                sort?: components["parameters"]["sort"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @example 1 */
                        total?: number;
                        data?: components["schemas"]["Account"][];
                    };
                };
            };
        };
    };
    getConfig: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ServerConfig"];
                };
            };
        };
    };
    getAbout: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ServerConfigAbout"];
                };
            };
        };
    };
    getCustomConfig: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ServerConfigCustom"];
                };
            };
        };
    };
    putCustomConfig: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Arises when:
             *       - the emailer is disabled and the instance is open to registrations
             *       - web videos and hls are disabled with transcoding enabled - you need at least one enabled
             *      */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    delCustomConfig: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getJobs: {
        parameters: {
            query?: {
                /** @description job type */
                jobType?: components["parameters"]["jobType"];
                /** @description Offset used to paginate results */
                start?: components["parameters"]["start"];
                /** @description Number of items to return */
                count?: components["parameters"]["count"];
                /** @description Sort column */
                sort?: components["parameters"]["sort"];
            };
            header?: never;
            path: {
                /** @description The state of the job ('' for for no filter) */
                state: "" | "active" | "completed" | "failed" | "waiting" | "delayed";
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @example 1 */
                        total?: number;
                        data?: components["schemas"]["Job"][];
                    };
                };
            };
        };
    };
    getUsers: {
        parameters: {
            query?: {
                /** @description Plain text search that will match with user usernames or emails */
                search?: components["parameters"]["usersSearch"];
                /** @description Filter results down to (un)banned users */
                blocked?: components["parameters"]["usersBlocked"];
                /** @description Offset used to paginate results */
                start?: components["parameters"]["start"];
                /** @description Number of items to return */
                count?: components["parameters"]["count"];
                /** @description Sort users by criteria */
                sort?: components["parameters"]["usersSort"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["User"][];
                };
            };
        };
    };
    addUser: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description If the smtp server is configured, you can leave the password empty and an email will be sent
         *     asking the user to set it first.
         *      */
        requestBody: {
            content: {
                "application/json": components["schemas"]["AddUser"];
            };
        };
        responses: {
            /** @description user created */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AddUserResponse"];
                };
            };
            /** @description insufficient authority to create an admin or moderator */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getUser: {
        parameters: {
            query?: {
                /** @description include statistics about the user (only available as a moderator/admin) */
                withStats?: boolean;
            };
            header?: never;
            path: {
                /** @description Entity id */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description As an admin/moderator, you can request a response augmented with statistics about the user's
             *     moderation relations and videos usage, by using the `withStats` parameter.
             *      */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["User"] | components["schemas"]["UserWithStats"];
                };
            };
        };
    };
    putUser: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Entity id */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["UpdateUser"];
            };
        };
        responses: {
            /** @description successful operation */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    delUser: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Entity id */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description successful operation */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getOAuthClient: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["OAuthClient"];
                };
            };
        };
    };
    getOAuthToken: {
        parameters: {
            query?: never;
            header?: {
                /** @description If the user enabled two factor authentication, you need to provide the OTP code in this header */
                "x-peertube-otp"?: string;
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/x-www-form-urlencoded": components["schemas"]["OAuthToken-password"] | components["schemas"]["OAuthToken-refresh_token"];
            };
        };
        responses: {
            /** @description successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @example Bearer */
                        token_type?: string;
                        /**
                         * @description valid for 1 day
                         * @example 90286a0bdf0f7315d9d3fe8dabf9e1d2be9c97d0
                         */
                        access_token?: string;
                        /**
                         * @description valid for 2 weeks
                         * @example 2e0d675df9fc96d2e4ec8a3ebbbf45eca9137bb7
                         */
                        refresh_token?: string;
                        /** @example 14399 */
                        expires_in?: number;
                        /** @example 1209600 */
                        refresh_token_expires_in?: number;
                    };
                };
            };
            /** @description Disambiguate via `code`:
             *     - `invalid_client` for an unmatched `client_id`
             *     - `invalid_grant` for unmatched credentials
             *      */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Disambiguate via `code`:
             *     - default value for a regular authentication failure
             *     - `invalid_token` for an expired token
             *     - `missing_two_factor` if two factor header is missing
             *      */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    revokeOAuthToken: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    resendEmailToVerifyUser: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": {
                    /** @description User email */
                    email: string;
                };
            };
        };
        responses: {
            /** @description successful operation */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    resendEmailToVerifyRegistration: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": {
                    /** @description Registration email */
                    email: string;
                };
            };
        };
        responses: {
            /** @description successful operation */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    verifyUser: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Entity id */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": {
                    /** Format: url */
                    verificationString: string;
                    isPendingEmail?: boolean;
                };
            };
        };
        responses: {
            /** @description successful operation */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description invalid verification string */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description user not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    verifyRegistrationEmail: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Registration ID */
                registrationId: components["parameters"]["registrationId"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": {
                    /** Format: url */
                    verificationString: string;
                };
            };
        };
        responses: {
            /** @description successful operation */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description invalid verification string */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description registration not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    requestTwoFactor: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Entity id */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": {
                    /** @description Password of the currently authenticated user */
                    currentPassword?: string;
                };
            };
        };
        responses: {
            /** @description successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["RequestTwoFactorResponse"][];
                };
            };
            /** @description invalid password */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description user not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    confirmTwoFactorRequest: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Entity id */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": {
                    /** @description Token to identify the two factor request */
                    requestToken: string;
                    /** @description OTP token generated by the app */
                    otpToken: string;
                };
            };
        };
        responses: {
            /** @description successful operation */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description invalid request token or OTP token */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description user not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    disableTwoFactor: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Entity id */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": {
                    /** @description Password of the currently authenticated user */
                    currentPassword?: string;
                };
            };
        };
        responses: {
            /** @description successful operation */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description invalid password */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description user not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    userImportResumable: {
        parameters: {
            query: {
                /** @description Created session id to proceed with. If you didn't send chunks in the last hour, it is
                 *     not valid anymore and you need to initialize a new upload.
                 *      */
                upload_id: components["parameters"]["resumableUploadId"];
            };
            header: {
                /** @description Specifies the bytes in the file that the request is uploading.
                 *
                 *     For example, a value of `bytes 0-262143/1000000` shows that the request is sending the first
                 *     262144 bytes (256 x 1024) in a 2,469,036 byte file.
                 *      */
                "Content-Range": components["parameters"]["resumableUploadChunkContentRangeHeader"];
                /** @description Size of the chunk that the request is sending.
                 *
                 *     Remember that larger chunks are more efficient. PeerTube's web client uses chunks varying from
                 *     1048576 bytes (~1MB) and increases or reduces size depending on connection health.
                 *      */
                "Content-Length": components["parameters"]["resumableUploadChunkContentLengthHeader"];
            };
            path: {
                /** @description User id */
                userId: components["parameters"]["userId"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/octet-stream": string;
            };
        };
        responses: {
            /** @description last chunk received: successful operation */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description resume incomplete */
            308: {
                headers: {
                    Range?: string;
                    "Content-Length"?: number;
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    userImportResumableInit: {
        parameters: {
            query?: never;
            header: {
                /** @description Number of bytes that will be uploaded in subsequent requests. Set this value to the size of the file you are uploading. */
                "X-Upload-Content-Length": components["parameters"]["resumableUploadInitContentLengthHeader"];
                /** @description MIME type of the file that you are uploading. Depending on your instance settings, acceptable values might vary. */
                "X-Upload-Content-Type": components["parameters"]["resumableUploadInitContentTypeHeader"];
            };
            path: {
                /** @description User id */
                userId: components["parameters"]["userId"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["UserImportResumable"];
            };
        };
        responses: {
            /** @description created */
            201: {
                headers: {
                    Location?: string;
                    "Content-Length"?: number;
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    userImportResumableCancel: {
        parameters: {
            query: {
                /** @description Created session id to proceed with. If you didn't send chunks in the last hour, it is
                 *     not valid anymore and you need to initialize a new upload.
                 *      */
                upload_id: components["parameters"]["resumableUploadId"];
            };
            header: {
                "Content-Length": number;
            };
            path: {
                /** @description User id */
                userId: components["parameters"]["userId"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description import cancelled */
            204: {
                headers: {
                    "Content-Length"?: number;
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getLatestUserImport: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description User id */
                userId: components["parameters"]["userId"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        id?: number;
                        state?: {
                            id?: components["schemas"]["UserImportState"];
                            label?: string;
                        };
                        /** Format: date-time */
                        createdAt?: string;
                    };
                };
            };
        };
    };
    requestUserExport: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description User id */
                userId: components["parameters"]["userId"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": {
                    /** @description Whether to include video files in the archive */
                    withVideoFiles?: boolean;
                };
            };
        };
        responses: {
            /** @description successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        export?: {
                            id?: number;
                        };
                    };
                };
            };
        };
    };
    listUserExports: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description User id */
                userId: components["parameters"]["userId"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        id?: number;
                        state?: {
                            id?: components["schemas"]["UserExportState"];
                            label?: string;
                        };
                        /** @description Size of the archive file in bytes */
                        size?: number;
                        /** @description This URL already contains the JWT token, so no additional authentication credentials are required */
                        privateDownloadUrl?: string;
                        /** Format: date-time */
                        createdAt?: string;
                        /** Format: date-time */
                        expiresOn?: string;
                    };
                };
            };
        };
    };
    deleteUserExport: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description User id */
                userId: components["parameters"]["userId"];
                /** @description Entity id */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description successful operation */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getUserInfo: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["User"][];
                };
            };
        };
    };
    putUserInfo: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["UpdateMe"];
            };
        };
        responses: {
            /** @description successful operation */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    registerUser: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["RegisterUser"];
            };
        };
        responses: {
            /** @description successful operation */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description request error */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description user registration is not enabled, user limit is reached, registration is not allowed for the ip, requires approval or blocked by a plugin */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description a user with this username, channel name or email already exists */
            409: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    requestRegistration: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["UserRegistrationRequest"];
            };
        };
        responses: {
            /** @description successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["UserRegistration"];
                };
            };
            /** @description request error or signup approval is not enabled on the instance */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description user registration is not enabled, user limit is reached, registration is not allowed for the ip or blocked by a plugin */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description a user or registration with this username, channel name or email already exists */
            409: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    acceptRegistration: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Registration ID */
                registrationId: components["parameters"]["registrationId"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["UserRegistrationAcceptOrReject"];
            };
        };
        responses: {
            /** @description successful operation */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    rejectRegistration: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Registration ID */
                registrationId: components["parameters"]["registrationId"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["UserRegistrationAcceptOrReject"];
            };
        };
        responses: {
            /** @description successful operation */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    deleteRegistration: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Registration ID */
                registrationId: components["parameters"]["registrationId"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description successful operation */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    listRegistrations: {
        parameters: {
            query?: {
                /** @description Offset used to paginate results */
                start?: components["parameters"]["start"];
                /** @description Number of items to return */
                count?: components["parameters"]["count"];
                search?: string;
                sort?: "-createdAt" | "createdAt" | "state" | "-state";
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @example 1 */
                        total?: number;
                        data?: components["schemas"]["UserRegistration"][];
                    };
                };
            };
        };
    };
    requestVideoToken: {
        parameters: {
            query?: never;
            header?: {
                /** @description Required on password protected video */
                "x-peertube-video-password"?: components["parameters"]["videoPasswordHeader"];
            };
            path: {
                /** @description The object id, uuid or short uuid */
                id: components["parameters"]["idOrUUID"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["VideoTokenResponse"];
                };
            };
            /** @description incorrect parameters */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description video not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getVideos: {
        parameters: {
            query?: {
                /** @description Offset used to paginate results */
                start?: components["parameters"]["start"];
                /** @description Number of items to return */
                count?: components["parameters"]["count"];
                /** @description if you don't need the `total` in the response */
                skipCount?: components["parameters"]["skipCount"];
                sort?: components["parameters"]["videosSort"];
                /** @description whether to include nsfw videos, if any */
                nsfw?: components["parameters"]["nsfw"];
                nsfwFlagsIncluded?: components["parameters"]["nsfwFlagsIncluded"];
                nsfwFlagsExcluded?: components["parameters"]["nsfwFlagsExcluded"];
                /** @description whether or not the video is a live */
                isLive?: components["parameters"]["isLive"];
                /** @description category id of the video (see [/videos/categories](#operation/getCategories)) */
                categoryOneOf?: components["parameters"]["categoryOneOf"];
                /** @description licence id of the video (see [/videos/licences](#operation/getLicences)) */
                licenceOneOf?: components["parameters"]["licenceOneOf"];
                /** @description language id of the video (see [/videos/languages](#operation/getLanguages)). Use `_unknown` to filter on videos that don't have a video language */
                languageOneOf?: components["parameters"]["languageOneOf"];
                /** @description tag(s) of the video */
                tagsOneOf?: components["parameters"]["tagsOneOf"];
                /** @description tag(s) of the video, where all should be present in the video */
                tagsAllOf?: components["parameters"]["tagsAllOf"];
                /** @description **PeerTube >= 4.0** Display only local or remote objects */
                isLocal?: components["parameters"]["isLocal"];
                /** @description **Only administrators and moderators can use this parameter**
                 *
                 *     Include additional videos in results (can be combined using bitwise or operator)
                 *     - `0` NONE
                 *     - `1` NOT_PUBLISHED_STATE
                 *     - `2` BLACKLISTED
                 *     - `4` BLOCKED_OWNER
                 *     - `8` FILES
                 *     - `16` CAPTIONS
                 *     - `32` VIDEO SOURCE
                 *      */
                include?: components["parameters"]["include"];
                /** @description **PeerTube >= 4.0** Display only videos that have HLS files */
                hasHLSFiles?: components["parameters"]["hasHLSFiles"];
                /** @description **PeerTube >= 6.0** Display only videos that have Web Video files */
                hasWebVideoFiles?: components["parameters"]["hasWebVideoFiles"];
                /** @description Find elements owned by this host */
                host?: components["parameters"]["host"];
                /** @description **PeerTube >= 6.2** **Admins and moderators only** filter on videos that contain one of these automatic tags */
                autoTagOneOf?: components["parameters"]["autoTagOneOfVideo"];
                /** @description **PeerTube >= 4.0** Display only videos in this specific privacy/privacies */
                privacyOneOf?: components["parameters"]["privacyOneOf"];
                /** @description Whether or not to exclude videos that are in the user's video history */
                excludeAlreadyWatched?: components["parameters"]["excludeAlreadyWatched"];
                /** @description Plain text search, applied to various parts of the model depending on endpoint */
                search?: components["parameters"]["search"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["VideoListResponse"];
                };
            };
        };
    };
    getCategories: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": string[];
                };
            };
        };
    };
    getLicences: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": string[];
                };
            };
        };
    };
    getLanguages: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": string[];
                };
            };
        };
    };
    getVideoPrivacyPolicies: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": string[];
                };
            };
        };
    };
    getVideo: {
        parameters: {
            query?: never;
            header?: {
                /** @description Required on password protected video */
                "x-peertube-video-password"?: components["parameters"]["videoPasswordHeader"];
            };
            path: {
                /** @description The object id, uuid or short uuid */
                id: components["parameters"]["idOrUUID"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["VideoDetails"];
                };
            };
            /** @description provide a correct password to access this password protected video */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    putVideo: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The object id, uuid or short uuid */
                id: components["parameters"]["idOrUUID"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "multipart/form-data": {
                    /**
                     * Format: binary
                     * @description Video thumbnail file
                     */
                    thumbnailfile?: string;
                    /**
                     * Format: binary
                     * @description Video preview file
                     */
                    previewfile?: string;
                    category?: components["schemas"]["VideoCategorySet"];
                    licence?: components["schemas"]["VideoLicenceSet"];
                    language?: components["schemas"]["VideoLanguageSet"];
                    privacy?: components["schemas"]["VideoPrivacySet"];
                    /** @description Video description */
                    description?: string;
                    /** @description Whether or not we wait transcoding before publish the video */
                    waitTranscoding?: string;
                    /**
                     * @description A text tell the audience how to support the video creator
                     * @example Please support our work on https://soutenir.framasoft.org/en/ <3
                     */
                    support?: string;
                    /** @description Whether or not this video contains sensitive content */
                    nsfw?: boolean;
                    /** @description More information about the sensitive content of the video */
                    nsfwSummary?: unknown;
                    nsfwFlags?: components["schemas"]["NSFWFlag"];
                    /** @description Video name */
                    name?: string;
                    /** @description Video tags (maximum 5 tags each between 2 and 30 characters) */
                    tags?: string[];
                    /**
                     * @deprecated
                     * @description Deprecated in 6.2, use commentsPolicy instead
                     */
                    commentsEnabled?: boolean;
                    commentsPolicy?: components["schemas"]["VideoCommentsPolicySet"];
                    /** @description Enable or disable downloading for this video */
                    downloadEnabled?: boolean;
                    /**
                     * Format: date-time
                     * @description Date when the content was originally published
                     */
                    originallyPublishedAt?: string | null;
                    scheduleUpdate?: components["schemas"]["VideoScheduledUpdate"];
                    videoPasswords?: components["schemas"]["AddVideoPasswords"];
                };
            };
        };
        responses: {
            /** @description successful operation */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    delVideo: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The object id, uuid or short uuid */
                id: components["parameters"]["idOrUUID"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description successful operation */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getVideoDesc: {
        parameters: {
            query?: never;
            header?: {
                /** @description Required on password protected video */
                "x-peertube-video-password"?: components["parameters"]["videoPasswordHeader"];
            };
            path: {
                /** @description The object id, uuid or short uuid */
                id: components["parameters"]["idOrUUID"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": string | null;
                };
            };
        };
    };
    addView: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The object id, uuid or short uuid */
                id: components["parameters"]["idOrUUID"];
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["UserViewingVideo"];
            };
        };
        responses: {
            /** @description successful operation */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    uploadLegacy: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "multipart/form-data": components["schemas"]["VideoUploadRequestLegacy"];
            };
        };
        responses: {
            /** @description successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["VideoUploadResponse"];
                };
            };
            /** @description video didn't pass upload filter */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description upload has timed out */
            408: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description If the response has no body, it means the reverse-proxy didn't let it through. Otherwise disambiguate via `code`:
             *     - `quota_reached` for quota limits whether daily or global
             *      */
            413: {
                headers: {
                    /** @description Maximum file size for the video */
                    "X-File-Maximum-Size"?: string;
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description video type unsupported */
            415: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description video unreadable */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    uploadResumable: {
        parameters: {
            query: {
                /** @description Created session id to proceed with. If you didn't send chunks in the last hour, it is
                 *     not valid anymore and you need to initialize a new upload.
                 *      */
                upload_id: components["parameters"]["resumableUploadId"];
            };
            header: {
                /** @description Specifies the bytes in the file that the request is uploading.
                 *
                 *     For example, a value of `bytes 0-262143/1000000` shows that the request is sending the first
                 *     262144 bytes (256 x 1024) in a 2,469,036 byte file.
                 *      */
                "Content-Range": components["parameters"]["resumableUploadChunkContentRangeHeader"];
                /** @description Size of the chunk that the request is sending.
                 *
                 *     Remember that larger chunks are more efficient. PeerTube's web client uses chunks varying from
                 *     1048576 bytes (~1MB) and increases or reduces size depending on connection health.
                 *      */
                "Content-Length": components["parameters"]["resumableUploadChunkContentLengthHeader"];
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/octet-stream": string;
            };
        };
        responses: {
            /** @description last chunk received */
            200: {
                headers: {
                    "Content-Length"?: number;
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["VideoUploadResponse"];
                };
            };
            /** @description resume incomplete */
            308: {
                headers: {
                    Range?: string;
                    "Content-Length"?: number;
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description video didn't pass upload filter */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description upload not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description chunk doesn't match range */
            409: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description video unreadable */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description too many concurrent requests */
            429: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description upload is already being processed */
            503: {
                headers: {
                    "Retry-After"?: number;
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    uploadResumableInit: {
        parameters: {
            query?: never;
            header: {
                /** @description Number of bytes that will be uploaded in subsequent requests. Set this value to the size of the file you are uploading. */
                "X-Upload-Content-Length": components["parameters"]["resumableUploadInitContentLengthHeader"];
                /** @description MIME type of the file that you are uploading. Depending on your instance settings, acceptable values might vary. */
                "X-Upload-Content-Type": components["parameters"]["resumableUploadInitContentTypeHeader"];
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["VideoUploadRequestResumable"];
            };
        };
        responses: {
            /** @description file already exists, send a [`resume`](https://github.com/kukhariev/node-uploadx/blob/master/proto.md) request instead */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description created */
            201: {
                headers: {
                    Location?: string;
                    "Content-Length"?: number;
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Disambiguate via `code`:
             *     - `max_file_size_reached` for the absolute file size limit
             *     - `quota_reached` for quota limits whether daily or global
             *      */
            413: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description video type unsupported */
            415: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    uploadResumableCancel: {
        parameters: {
            query: {
                /** @description Created session id to proceed with. If you didn't send chunks in the last hour, it is
                 *     not valid anymore and you need to initialize a new upload.
                 *      */
                upload_id: components["parameters"]["resumableUploadId"];
            };
            header: {
                "Content-Length": number;
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description upload cancelled */
            204: {
                headers: {
                    "Content-Length"?: number;
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description upload not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    importVideo: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "multipart/form-data": components["schemas"]["VideoCreateImport"];
            };
        };
        responses: {
            /** @description successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["VideoUploadResponse"];
                };
            };
            /** @description `magnetUri` or `targetUrl` or a torrent file missing */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description video didn't pass pre-import filter */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description HTTP or Torrent/magnetURI import not enabled */
            409: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    addLive: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "multipart/form-data": {
                    /** @description Channel id that will contain this live video */
                    channelId: number;
                    saveReplay?: boolean;
                    replaySettings?: components["schemas"]["LiveVideoReplaySettings"];
                    /** @description User can stream multiple times in a permanent live */
                    permanentLive?: boolean;
                    /** @description User can select live latency mode if enabled by the instance */
                    latencyMode?: components["schemas"]["LiveVideoLatencyMode"];
                    /**
                     * Format: binary
                     * @description Live video/replay thumbnail file
                     */
                    thumbnailfile?: string;
                    /**
                     * Format: binary
                     * @description Live video/replay preview file
                     */
                    previewfile?: string;
                    privacy?: components["schemas"]["VideoPrivacySet"];
                    category?: components["schemas"]["VideoCategorySet"];
                    licence?: components["schemas"]["VideoLicenceSet"];
                    language?: components["schemas"]["VideoLanguageSet"];
                    /** @description Live video/replay description */
                    description?: string;
                    /**
                     * @description A text tell the audience how to support the creator
                     * @example Please support our work on https://soutenir.framasoft.org/en/ <3
                     */
                    support?: string;
                    /** @description Whether or not this live video/replay contains sensitive content */
                    nsfw?: boolean;
                    /** @description More information about the sensitive content of the video */
                    nsfwSummary?: unknown;
                    nsfwFlags?: components["schemas"]["NSFWFlag"];
                    /** @description Live video/replay name */
                    name: string;
                    /** @description Live video/replay tags (maximum 5 tags each between 2 and 30 characters) */
                    tags?: string[];
                    /**
                     * @deprecated
                     * @description Deprecated in 6.2, use commentsPolicy instead
                     */
                    commentsEnabled?: boolean;
                    commentsPolicy?: components["schemas"]["VideoCommentsPolicySet"];
                    /** @description Enable or disable downloading for the replay of this live video */
                    downloadEnabled?: boolean;
                };
            };
        };
        responses: {
            /** @description successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["VideoUploadResponse"];
                };
            };
            /** @description Disambiguate via `code`:
             *     - default type for a validation error
             *     - `live_conflicting_permanent_and_save_replay` for conflicting parameters set
             *      */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Disambiguate via `code`:
             *     - `live_not_enabled` for a disabled live feature
             *     - `live_not_allowing_replay` for a disabled replay feature
             *     - `max_instance_lives_limit_reached` for the absolute concurrent live limit
             *     - `max_user_lives_limit_reached` for the user concurrent live limit
             *      */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getLiveId: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The object id, uuid or short uuid */
                id: components["parameters"]["idOrUUID"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["LiveVideoResponse"];
                };
            };
        };
    };
    updateLiveId: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The object id, uuid or short uuid */
                id: components["parameters"]["idOrUUID"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["LiveVideoUpdate"];
            };
        };
        responses: {
            /** @description successful operation */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description bad parameters or trying to update a live that has already started */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description trying to save replay of the live but saving replay is not enabled on the instance */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getVideoSource: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The object id, uuid or short uuid */
                id: components["parameters"]["idOrUUID"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["VideoSource"];
                };
            };
        };
    };
    deleteVideoSourceFile: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The object id, uuid or short uuid */
                id: components["parameters"]["idOrUUID"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description successful operation */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description video source not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    replaceVideoSourceResumable: {
        parameters: {
            query: {
                /** @description Created session id to proceed with. If you didn't send chunks in the last hour, it is
                 *     not valid anymore and you need to initialize a new upload.
                 *      */
                upload_id: components["parameters"]["resumableUploadId"];
            };
            header: {
                /** @description Specifies the bytes in the file that the request is uploading.
                 *
                 *     For example, a value of `bytes 0-262143/1000000` shows that the request is sending the first
                 *     262144 bytes (256 x 1024) in a 2,469,036 byte file.
                 *      */
                "Content-Range": components["parameters"]["resumableUploadChunkContentRangeHeader"];
                /** @description Size of the chunk that the request is sending.
                 *
                 *     Remember that larger chunks are more efficient. PeerTube's web client uses chunks varying from
                 *     1048576 bytes (~1MB) and increases or reduces size depending on connection health.
                 *      */
                "Content-Length": components["parameters"]["resumableUploadChunkContentLengthHeader"];
            };
            path: {
                /** @description The object id, uuid or short uuid */
                id: components["parameters"]["idOrUUID"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/octet-stream": string;
            };
        };
        responses: {
            /** @description last chunk received: successful operation */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description resume incomplete */
            308: {
                headers: {
                    Range?: string;
                    "Content-Length"?: number;
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description video didn't pass file replacement filter */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description replace upload not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description chunk doesn't match range */
            409: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description video unreadable */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description too many concurrent requests */
            429: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description upload is already being processed */
            503: {
                headers: {
                    "Retry-After"?: number;
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    replaceVideoSourceResumableInit: {
        parameters: {
            query?: never;
            header: {
                /** @description Number of bytes that will be uploaded in subsequent requests. Set this value to the size of the file you are uploading. */
                "X-Upload-Content-Length": components["parameters"]["resumableUploadInitContentLengthHeader"];
                /** @description MIME type of the file that you are uploading. Depending on your instance settings, acceptable values might vary. */
                "X-Upload-Content-Type": components["parameters"]["resumableUploadInitContentTypeHeader"];
            };
            path: {
                /** @description The object id, uuid or short uuid */
                id: components["parameters"]["idOrUUID"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["VideoReplaceSourceRequestResumable"];
            };
        };
        responses: {
            /** @description file already exists, send a [`resume`](https://github.com/kukhariev/node-uploadx/blob/master/proto.md) request instead */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description created */
            201: {
                headers: {
                    Location?: string;
                    "Content-Length"?: number;
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Disambiguate via `code`:
             *     - `max_file_size_reached` for the absolute file size limit
             *     - `quota_reached` for quota limits whether daily or global
             *      */
            413: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description video type unsupported */
            415: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    replaceVideoSourceResumableCancel: {
        parameters: {
            query: {
                /** @description Created session id to proceed with. If you didn't send chunks in the last hour, it is
                 *     not valid anymore and you need to initialize a new upload.
                 *      */
                upload_id: components["parameters"]["resumableUploadId"];
            };
            header: {
                "Content-Length": number;
            };
            path: {
                /** @description The object id, uuid or short uuid */
                id: components["parameters"]["idOrUUID"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description source file replacement cancelled */
            204: {
                headers: {
                    "Content-Length"?: number;
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description source file replacement not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getMyAbuses: {
        parameters: {
            query?: {
                /** @description only list the report with this id */
                id?: number;
                state?: components["schemas"]["AbuseStateSet"];
                /** @description Sort abuses by criteria */
                sort?: components["parameters"]["abusesSort"];
                /** @description Offset used to paginate results */
                start?: components["parameters"]["start"];
                /** @description Number of items to return */
                count?: components["parameters"]["count"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @example 1 */
                        total?: number;
                        data?: components["schemas"]["Abuse"][];
                    };
                };
            };
        };
    };
    getAbuses: {
        parameters: {
            query?: {
                /** @description only list the report with this id */
                id?: number;
                /** @description predefined reason the listed reports should contain */
                predefinedReason?: components["schemas"]["PredefinedAbuseReasons"];
                /** @description plain search that will match with video titles, reporter names and more */
                search?: string;
                state?: components["schemas"]["AbuseStateSet"];
                /** @description only list reports of a specific reporter */
                searchReporter?: string;
                /** @description only list reports of a specific reportee */
                searchReportee?: string;
                /** @description only list reports of a specific video */
                searchVideo?: string;
                /** @description only list reports of a specific video channel */
                searchVideoChannel?: string;
                /** @description only list deleted or blocklisted videos */
                videoIs?: "deleted" | "blacklisted";
                /** @description only list account, comment or video reports */
                filter?: "video" | "comment" | "account";
                /** @description Offset used to paginate results */
                start?: components["parameters"]["start"];
                /** @description Number of items to return */
                count?: components["parameters"]["count"];
                /** @description Sort abuses by criteria */
                sort?: components["parameters"]["abusesSort"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @example 1 */
                        total?: number;
                        data?: components["schemas"]["Abuse"][];
                    };
                };
            };
        };
    };
    addVideoBlock: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The object id, uuid or short uuid */
                id: components["parameters"]["idOrUUID"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description successful operation */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    delVideoBlock: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The object id, uuid or short uuid */
                id: components["parameters"]["idOrUUID"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description successful operation */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description block not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getVideoBlocks: {
        parameters: {
            query?: {
                /** @description list only blocks that match this type:
                 *     - `1`: manual block
                 *     - `2`: automatic block that needs review
                 *      */
                type?: 1 | 2;
                /** @description plain search that will match with video titles, and more */
                search?: string;
                /** @description Offset used to paginate results */
                start?: components["parameters"]["start"];
                /** @description Number of items to return */
                count?: components["parameters"]["count"];
                /** @description Sort blocklists by criteria */
                sort?: components["parameters"]["blacklistsSort"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @example 1 */
                        total?: number;
                        data?: components["schemas"]["VideoBlacklist"][];
                    };
                };
            };
        };
    };
    listVideoStoryboards: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The object id, uuid or short uuid */
                id: components["parameters"]["idOrUUID"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        storyboards?: components["schemas"]["Storyboard"][];
                    };
                };
            };
        };
    };
    getVideoCaptions: {
        parameters: {
            query?: never;
            header?: {
                /** @description Required on password protected video */
                "x-peertube-video-password"?: components["parameters"]["videoPasswordHeader"];
            };
            path: {
                /** @description The object id, uuid or short uuid */
                id: components["parameters"]["idOrUUID"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @example 1 */
                        total?: number;
                        data?: components["schemas"]["VideoCaption"][];
                    };
                };
            };
        };
    };
    generateVideoCaption: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The object id, uuid or short uuid */
                id: components["parameters"]["idOrUUID"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": {
                    /** @default false */
                    forceTranscription?: boolean;
                };
            };
        };
        responses: {
            /** @description successful operation */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description video not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    addVideoCaption: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The object id, uuid or short uuid */
                id: components["parameters"]["idOrUUID"];
                /** @description The caption language */
                captionLanguage: components["parameters"]["captionLanguage"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "multipart/form-data": {
                    /**
                     * Format: binary
                     * @description The file to upload.
                     */
                    captionfile?: string;
                };
            };
        };
        responses: {
            /** @description successful operation */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description video or language not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    delVideoCaption: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The object id, uuid or short uuid */
                id: components["parameters"]["idOrUUID"];
                /** @description The caption language */
                captionLanguage: components["parameters"]["captionLanguage"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description successful operation */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description video or language or caption for that language not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getVideoChapters: {
        parameters: {
            query?: never;
            header?: {
                /** @description Required on password protected video */
                "x-peertube-video-password"?: components["parameters"]["videoPasswordHeader"];
            };
            path: {
                /** @description The object id, uuid or short uuid */
                id: components["parameters"]["idOrUUID"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["VideoChapters"];
                };
            };
        };
    };
    replaceVideoChapters: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The object id, uuid or short uuid */
                id: components["parameters"]["idOrUUID"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": {
                    chapters?: {
                        title?: string;
                        timecode?: number;
                    }[];
                };
            };
        };
        responses: {
            /** @description successful operation */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description video not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getVideoChannels: {
        parameters: {
            query?: {
                /** @description Offset used to paginate results */
                start?: components["parameters"]["start"];
                /** @description Number of items to return */
                count?: components["parameters"]["count"];
                /** @description Sort column */
                sort?: components["parameters"]["sort"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["VideoChannelList"];
                };
            };
        };
    };
    addVideoChannel: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["VideoChannelCreate"];
            };
        };
        responses: {
            /** @description successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        videoChannel?: {
                            id?: components["schemas"]["id"];
                        };
                    };
                };
            };
        };
    };
    getVideoChannel: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The video channel handle */
                channelHandle: components["parameters"]["channelHandle"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["VideoChannel"];
                };
            };
        };
    };
    putVideoChannel: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The video channel handle */
                channelHandle: components["parameters"]["channelHandle"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["VideoChannelUpdate"];
            };
        };
        responses: {
            /** @description successful operation */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    delVideoChannel: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The video channel handle */
                channelHandle: components["parameters"]["channelHandle"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description successful operation */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getVideoChannelVideos: {
        parameters: {
            query?: {
                /** @description Offset used to paginate results */
                start?: components["parameters"]["start"];
                /** @description Number of items to return */
                count?: components["parameters"]["count"];
                /** @description if you don't need the `total` in the response */
                skipCount?: components["parameters"]["skipCount"];
                sort?: components["parameters"]["videosSort"];
                /** @description whether to include nsfw videos, if any */
                nsfw?: components["parameters"]["nsfw"];
                nsfwFlagsIncluded?: components["parameters"]["nsfwFlagsIncluded"];
                nsfwFlagsExcluded?: components["parameters"]["nsfwFlagsExcluded"];
                /** @description whether or not the video is a live */
                isLive?: components["parameters"]["isLive"];
                /** @description category id of the video (see [/videos/categories](#operation/getCategories)) */
                categoryOneOf?: components["parameters"]["categoryOneOf"];
                /** @description licence id of the video (see [/videos/licences](#operation/getLicences)) */
                licenceOneOf?: components["parameters"]["licenceOneOf"];
                /** @description language id of the video (see [/videos/languages](#operation/getLanguages)). Use `_unknown` to filter on videos that don't have a video language */
                languageOneOf?: components["parameters"]["languageOneOf"];
                /** @description tag(s) of the video */
                tagsOneOf?: components["parameters"]["tagsOneOf"];
                /** @description tag(s) of the video, where all should be present in the video */
                tagsAllOf?: components["parameters"]["tagsAllOf"];
                /** @description **PeerTube >= 4.0** Display only local or remote objects */
                isLocal?: components["parameters"]["isLocal"];
                /** @description **Only administrators and moderators can use this parameter**
                 *
                 *     Include additional videos in results (can be combined using bitwise or operator)
                 *     - `0` NONE
                 *     - `1` NOT_PUBLISHED_STATE
                 *     - `2` BLACKLISTED
                 *     - `4` BLOCKED_OWNER
                 *     - `8` FILES
                 *     - `16` CAPTIONS
                 *     - `32` VIDEO SOURCE
                 *      */
                include?: components["parameters"]["include"];
                /** @description **PeerTube >= 4.0** Display only videos that have HLS files */
                hasHLSFiles?: components["parameters"]["hasHLSFiles"];
                /** @description **PeerTube >= 6.0** Display only videos that have Web Video files */
                hasWebVideoFiles?: components["parameters"]["hasWebVideoFiles"];
                /** @description Find elements owned by this host */
                host?: components["parameters"]["host"];
                /** @description **PeerTube >= 6.2** **Admins and moderators only** filter on videos that contain one of these automatic tags */
                autoTagOneOf?: components["parameters"]["autoTagOneOfVideo"];
                /** @description **PeerTube >= 4.0** Display only videos in this specific privacy/privacies */
                privacyOneOf?: components["parameters"]["privacyOneOf"];
                /** @description Whether or not to exclude videos that are in the user's video history */
                excludeAlreadyWatched?: components["parameters"]["excludeAlreadyWatched"];
                /** @description Plain text search, applied to various parts of the model depending on endpoint */
                search?: components["parameters"]["search"];
            };
            header?: never;
            path: {
                /** @description The video channel handle */
                channelHandle: components["parameters"]["channelHandle"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["VideoListResponse"];
                };
            };
        };
    };
    getVideoChannelFollowers: {
        parameters: {
            query?: {
                /** @description Offset used to paginate results */
                start?: components["parameters"]["start"];
                /** @description Number of items to return */
                count?: components["parameters"]["count"];
                /** @description Sort followers by criteria */
                sort?: components["parameters"]["followersSort"];
                /** @description Plain text search, applied to various parts of the model depending on endpoint */
                search?: components["parameters"]["search"];
            };
            header?: never;
            path: {
                /** @description The video channel handle */
                channelHandle: components["parameters"]["channelHandle"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @example 1 */
                        total?: number;
                        data?: components["schemas"]["Follow"][];
                    };
                };
            };
        };
    };
    addVideoChannelSync: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["VideoChannelSyncCreate"];
            };
        };
        responses: {
            /** @description successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        videoChannelSync?: components["schemas"]["VideoChannelSync"];
                    };
                };
            };
        };
    };
    delVideoChannelSync: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Channel Sync id */
                channelSyncId: components["parameters"]["channelSyncId"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description successful operation */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    triggerVideoChannelSync: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Channel Sync id */
                channelSyncId: components["parameters"]["channelSyncId"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description successful operation */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getPlaylistPrivacyPolicies: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": string[];
                };
            };
        };
    };
    getPlaylists: {
        parameters: {
            query?: {
                /** @description Offset used to paginate results */
                start?: components["parameters"]["start"];
                /** @description Number of items to return */
                count?: components["parameters"]["count"];
                /** @description Sort column */
                sort?: components["parameters"]["sort"];
                playlistType?: components["parameters"]["videoPlaylistType"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @example 1 */
                        total?: number;
                        data?: components["schemas"]["VideoPlaylist"][];
                    };
                };
            };
        };
    };
    addPlaylist: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "multipart/form-data": {
                    /** @description Video playlist display name */
                    displayName: string;
                    /**
                     * Format: binary
                     * @description Video playlist thumbnail file
                     */
                    thumbnailfile?: string;
                    privacy?: components["schemas"]["VideoPlaylistPrivacySet"];
                    /** @description Video playlist description */
                    description?: string;
                    /** @description Video channel in which the playlist will be published */
                    videoChannelId?: components["schemas"]["id"];
                };
            };
        };
        responses: {
            /** @description successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        videoPlaylist?: {
                            id?: components["schemas"]["VideoPlaylist"]["id"];
                            uuid?: components["schemas"]["VideoPlaylist"]["uuid"];
                            shortUUID?: components["schemas"]["VideoPlaylist"]["shortUUID"];
                        };
                    };
                };
            };
        };
    };
    getVideoPlaylistVideos: {
        parameters: {
            query?: {
                /** @description Offset used to paginate results */
                start?: components["parameters"]["start"];
                /** @description Number of items to return */
                count?: components["parameters"]["count"];
            };
            header?: never;
            path: {
                /** @description Playlist id */
                playlistId: components["parameters"]["playlistId"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @example 1 */
                        total?: number;
                        data?: {
                            /** @description object id for the video */
                            id?: components["schemas"]["id"];
                            /** @example 2 */
                            position?: number;
                            /**
                             * Format: seconds
                             * @example 10
                             */
                            startTimestamp?: number | null;
                            /**
                             * Format: seconds
                             * @example 42
                             */
                            stopTimestamp?: number | null;
                            video?: components["schemas"]["Video"];
                        }[];
                    };
                };
            };
        };
    };
    addVideoPlaylistVideo: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Playlist id */
                playlistId: components["parameters"]["playlistId"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": {
                    /** @description Video to add in the playlist */
                    videoId: components["schemas"]["Video"]["uuid"] | components["schemas"]["Video"]["id"];
                    /**
                     * Format: seconds
                     * @description Start the video at this specific timestamp
                     */
                    startTimestamp?: number;
                    /**
                     * Format: seconds
                     * @description Stop the video at this specific timestamp
                     */
                    stopTimestamp?: number;
                };
            };
        };
        responses: {
            /** @description successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        videoPlaylistElement?: {
                            /** @example 2 */
                            id?: number;
                        };
                    };
                };
            };
        };
    };
    reorderVideoPlaylist: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Playlist id */
                playlistId: components["parameters"]["playlistId"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": {
                    /** @description Start position of the element to reorder */
                    startPosition: number;
                    /** @description New position for the block to reorder, to add the block before the first element */
                    insertAfterPosition: number;
                    /** @description How many element from `startPosition` to reorder */
                    reorderLength?: number;
                };
            };
        };
        responses: {
            /** @description successful operation */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    putVideoPlaylistVideo: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Playlist id */
                playlistId: components["parameters"]["playlistId"];
                /** @description Playlist element id */
                playlistElementId: components["parameters"]["playlistElementId"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": {
                    /**
                     * Format: seconds
                     * @description Start the video at this specific timestamp
                     */
                    startTimestamp?: number;
                    /**
                     * Format: seconds
                     * @description Stop the video at this specific timestamp
                     */
                    stopTimestamp?: number;
                };
            };
        };
        responses: {
            /** @description successful operation */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    delVideoPlaylistVideo: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Playlist id */
                playlistId: components["parameters"]["playlistId"];
                /** @description Playlist element id */
                playlistElementId: components["parameters"]["playlistElementId"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description successful operation */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    delVideoHLS: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The object id, uuid or short uuid */
                id: components["parameters"]["idOrUUID"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description successful operation */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description video does not exist */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    delVideoWebVideos: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The object id, uuid or short uuid */
                id: components["parameters"]["idOrUUID"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description successful operation */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description video does not exist */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    createVideoTranscoding: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The object id, uuid or short uuid */
                id: components["parameters"]["idOrUUID"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": {
                    /** @enum {string} */
                    transcodingType: "hls" | "web-video";
                    /**
                     * @description If the video is stuck in transcoding state, do it anyway
                     * @default false
                     */
                    forceTranscoding?: boolean;
                };
            };
        };
        responses: {
            /** @description successful operation */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description video does not exist */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    searchVideos: {
        parameters: {
            query: {
                /** @description String to search. If the user can make a remote URI search, and the string is an URI then the PeerTube instance will fetch the remote object and add it to its database. Then, you can use the REST API to fetch the complete video information and interact with it.
                 *      */
                search: string;
                /** @description Find elements with specific UUIDs */
                uuids?: components["parameters"]["uuids"];
                /** @description If the administrator enabled search index support, you can override the default search target.
                 *
                 *     **Warning**: If you choose to make an index search, PeerTube will get results from a third party service. It means the instance may not yet know the objects you fetched. If you want to load video/channel information:
                 *       * If the current user has the ability to make a remote URI search (this information is available in the config endpoint),
                 *       then reuse the search API to make a search using the object URI so PeerTube instance fetches the remote object and fill its database.
                 *       After that, you can use the classic REST API endpoints to fetch the complete object or interact with it
                 *       * If the current user doesn't have the ability to make a remote URI search, then redirect the user on the origin instance or fetch
                 *       the data from the origin instance API
                 *      */
                searchTarget?: components["parameters"]["searchTarget"];
                /** @description Offset used to paginate results */
                start?: components["parameters"]["start"];
                /** @description Number of items to return */
                count?: components["parameters"]["count"];
                /** @description if you don't need the `total` in the response */
                skipCount?: components["parameters"]["skipCount"];
                sort?: components["parameters"]["videosSort"];
                /** @description whether to include nsfw videos, if any */
                nsfw?: components["parameters"]["nsfw"];
                nsfwFlagsIncluded?: components["parameters"]["nsfwFlagsIncluded"];
                nsfwFlagsExcluded?: components["parameters"]["nsfwFlagsExcluded"];
                /** @description whether or not the video is a live */
                isLive?: components["parameters"]["isLive"];
                /** @description category id of the video (see [/videos/categories](#operation/getCategories)) */
                categoryOneOf?: components["parameters"]["categoryOneOf"];
                /** @description licence id of the video (see [/videos/licences](#operation/getLicences)) */
                licenceOneOf?: components["parameters"]["licenceOneOf"];
                /** @description language id of the video (see [/videos/languages](#operation/getLanguages)). Use `_unknown` to filter on videos that don't have a video language */
                languageOneOf?: components["parameters"]["languageOneOf"];
                /** @description tag(s) of the video */
                tagsOneOf?: components["parameters"]["tagsOneOf"];
                /** @description tag(s) of the video, where all should be present in the video */
                tagsAllOf?: components["parameters"]["tagsAllOf"];
                /** @description **PeerTube >= 4.0** Display only local or remote objects */
                isLocal?: components["parameters"]["isLocal"];
                /** @description **Only administrators and moderators can use this parameter**
                 *
                 *     Include additional videos in results (can be combined using bitwise or operator)
                 *     - `0` NONE
                 *     - `1` NOT_PUBLISHED_STATE
                 *     - `2` BLACKLISTED
                 *     - `4` BLOCKED_OWNER
                 *     - `8` FILES
                 *     - `16` CAPTIONS
                 *     - `32` VIDEO SOURCE
                 *      */
                include?: components["parameters"]["include"];
                /** @description **PeerTube >= 4.0** Display only videos that have HLS files */
                hasHLSFiles?: components["parameters"]["hasHLSFiles"];
                /** @description **PeerTube >= 6.0** Display only videos that have Web Video files */
                hasWebVideoFiles?: components["parameters"]["hasWebVideoFiles"];
                /** @description Find elements owned by this host */
                host?: components["parameters"]["host"];
                /** @description **PeerTube >= 6.2** **Admins and moderators only** filter on videos that contain one of these automatic tags */
                autoTagOneOf?: components["parameters"]["autoTagOneOfVideo"];
                /** @description **PeerTube >= 4.0** Display only videos in this specific privacy/privacies */
                privacyOneOf?: components["parameters"]["privacyOneOf"];
                /** @description Whether or not to exclude videos that are in the user's video history */
                excludeAlreadyWatched?: components["parameters"]["excludeAlreadyWatched"];
                /** @description Get videos that are published after this date */
                startDate?: string;
                /** @description Get videos that are published before this date */
                endDate?: string;
                /** @description Get videos that are originally published after this date */
                originallyPublishedStartDate?: string;
                /** @description Get videos that are originally published before this date */
                originallyPublishedEndDate?: string;
                /** @description Get videos that have this minimum duration */
                durationMin?: number;
                /** @description Get videos that have this maximum duration */
                durationMax?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["VideoListResponse"];
                };
            };
            /** @description search index unavailable */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    searchChannels: {
        parameters: {
            query: {
                /** @description String to search. If the user can make a remote URI search, and the string is an URI then the PeerTube instance will fetch the remote object and add it to its database. Then, you can use the REST API to fetch the complete channel information and interact with it.
                 *      */
                search: string;
                /** @description Offset used to paginate results */
                start?: components["parameters"]["start"];
                /** @description Number of items to return */
                count?: components["parameters"]["count"];
                /** @description If the administrator enabled search index support, you can override the default search target.
                 *
                 *     **Warning**: If you choose to make an index search, PeerTube will get results from a third party service. It means the instance may not yet know the objects you fetched. If you want to load video/channel information:
                 *       * If the current user has the ability to make a remote URI search (this information is available in the config endpoint),
                 *       then reuse the search API to make a search using the object URI so PeerTube instance fetches the remote object and fill its database.
                 *       After that, you can use the classic REST API endpoints to fetch the complete object or interact with it
                 *       * If the current user doesn't have the ability to make a remote URI search, then redirect the user on the origin instance or fetch
                 *       the data from the origin instance API
                 *      */
                searchTarget?: components["parameters"]["searchTarget"];
                /** @description Sort column */
                sort?: components["parameters"]["sort"];
                /** @description Find elements owned by this host */
                host?: components["parameters"]["host"];
                /** @description Find elements with these handles */
                handles?: components["parameters"]["handles"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["VideoChannelList"];
                };
            };
            /** @description search index unavailable */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    searchPlaylists: {
        parameters: {
            query: {
                /** @description String to search. If the user can make a remote URI search, and the string is an URI then the PeerTube instance will fetch the remote object and add it to its database. Then, you can use the REST API to fetch the complete playlist information and interact with it.
                 *      */
                search: string;
                /** @description Offset used to paginate results */
                start?: components["parameters"]["start"];
                /** @description Number of items to return */
                count?: components["parameters"]["count"];
                /** @description If the administrator enabled search index support, you can override the default search target.
                 *
                 *     **Warning**: If you choose to make an index search, PeerTube will get results from a third party service. It means the instance may not yet know the objects you fetched. If you want to load video/channel information:
                 *       * If the current user has the ability to make a remote URI search (this information is available in the config endpoint),
                 *       then reuse the search API to make a search using the object URI so PeerTube instance fetches the remote object and fill its database.
                 *       After that, you can use the classic REST API endpoints to fetch the complete object or interact with it
                 *       * If the current user doesn't have the ability to make a remote URI search, then redirect the user on the origin instance or fetch
                 *       the data from the origin instance API
                 *      */
                searchTarget?: components["parameters"]["searchTarget"];
                /** @description Sort column */
                sort?: components["parameters"]["sort"];
                /** @description Find elements owned by this host */
                host?: components["parameters"]["host"];
                /** @description Find elements with specific UUIDs */
                uuids?: components["parameters"]["uuids"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @example 1 */
                        total?: number;
                        data?: components["schemas"]["VideoPlaylist"][];
                    };
                };
            };
            /** @description search index unavailable */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getMirroredVideos: {
        parameters: {
            query: {
                /** @description direction of the mirror */
                target: "my-videos" | "remote-videos";
                /** @description Offset used to paginate results */
                start?: components["parameters"]["start"];
                /** @description Number of items to return */
                count?: components["parameters"]["count"];
                /** @description Sort abuses by criteria */
                sort?: components["parameters"]["videoRedundanciesSort"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["VideoRedundancy"][];
                };
            };
        };
    };
    putMirroredVideo: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": {
                    videoId: components["schemas"]["Video"]["id"];
                };
            };
        };
        responses: {
            /** @description successful operation */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description cannot mirror a local video */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description video does not exist */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description video is already mirrored */
            409: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    delMirroredVideo: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description id of an existing redundancy on a video */
                redundancyId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description successful operation */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description video redundancy not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getInstanceStats: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ServerStats"];
                };
            };
        };
    };
    sendClientLog: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["SendClientLog"];
            };
        };
        responses: {
            /** @description successful operation */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getInstanceLogs: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": string[];
                };
            };
        };
    };
    getInstanceAuditLogs: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": string[];
                };
            };
        };
    };
    getPlugins: {
        parameters: {
            query?: {
                pluginType?: number;
                uninstalled?: boolean;
                /** @description Offset used to paginate results */
                start?: components["parameters"]["start"];
                /** @description Number of items to return */
                count?: components["parameters"]["count"];
                /** @description Sort column */
                sort?: components["parameters"]["sort"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PluginResponse"];
                };
            };
        };
    };
    getAvailablePlugins: {
        parameters: {
            query?: {
                search?: string;
                pluginType?: number;
                currentPeerTubeEngine?: string;
                /** @description Offset used to paginate results */
                start?: components["parameters"]["start"];
                /** @description Number of items to return */
                count?: components["parameters"]["count"];
                /** @description Sort column */
                sort?: components["parameters"]["sort"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PluginResponse"];
                };
            };
            /** @description plugin index unavailable */
            503: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    addPlugin: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": {
                    /** @example peertube-plugin-auth-ldap */
                    npmName: string;
                } | {
                    path: string;
                };
            };
        };
        responses: {
            /** @description successful operation */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description should have either `npmName` or `path` set */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    updatePlugin: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": {
                    /** @example peertube-plugin-auth-ldap */
                    npmName: string;
                } | {
                    path: string;
                };
            };
        };
        responses: {
            /** @description successful operation */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description should have either `npmName` or `path` set */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description existing plugin not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    uninstallPlugin: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": {
                    /**
                     * @description name of the plugin/theme in its package.json
                     * @example peertube-plugin-auth-ldap
                     */
                    npmName: string;
                };
            };
        };
        responses: {
            /** @description successful operation */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description existing plugin not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getPlugin: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description name of the plugin/theme on npmjs.com or in its package.json */
                npmName: components["parameters"]["npmName"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Plugin"];
                };
            };
            /** @description plugin not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
}
type WithRequired<T, K extends keyof T> = T & {
    [P in K]-?: T[P];
};
